var tipuesearch = {"pages": [
     {"title": "introduction", "text": "     <p>     <p>Licence : MPL    <p><h2 class=\"\"><span id=\"SecPreface\"></span>Preface Preface</h2>      <p>GLZ-MathsClasses, may replace and extend standard math functions from FPC/Lazarus library. <br> It is optimized for x86-32 &amp; x86-64 Windows, Unix systems based. <br> It is provides robust, optimized and efficient standard and vectorizable math functions such as <a class=\"normal\" href=\"GLZMath.html#Sqrt\">sqrt</a>, <a class=\"normal\" href=\"GLZMath.html#Sin\">sin</a>, or atan. <br> It is define a set of functions to compute common mathematical operations, vector, matrix, quaternion, euler, plane operations and transformations. <br> Also provide extra operations for specific mathematical algorithms for 2D/3D rendering systems.<br> It is include some function in the way of standard GLSL and HLSL scripting like <a class=\"normal\" href=\"GLZMath.html#SmoothStep\">SmoothStep</a>, FaceFoward, Reflect, ect... A set of functions provides a fast approximation to sine, cosine, square root, <a class=\"normal\" href=\"GLZMath.html#ArcTan2\">arctan2</a>, ect...( Taylor, Remez, Quadratic, LUT... algorithms). Accuracy can differ from one algorith to one other.    <p>For fast computing we use SIMD instructions (SSE / SSE2 / SSE3 / AVX /AVX2) in some severals vectorizable functions.    <p>All function have passed Functionnals test in UnitTest.    <p>This math library is much faster than standard FPC/Lazarus functions. See the benchmarks to compare speed of each function.    <p><h2 class=\"\"><span id=\"SecArchDsgn\"></span>Architecture and Design</h2>      <p>Trigonometric fast and approximation math operations such <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a>, <a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a>, <a class=\"normal\" href=\"GLZMath.html#ArcTan2\">ArcTan2</a> ect.. are on single-precision floating-point values only. Double-precision floating-point arithmetic is unsupported with fast math functions.    <p>2D, 3D and 4-Dimensional vectors, of type Byte, Single Integer are supported.<br> Respectively <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> @TODO : Type of Double are only support in 2D vectors.<br> <b>Note : </b> 3D Vectors type have no advanced design (<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a>). Except for type of Byte (<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>).    <p>Provides 2x2, 4x4 Matrices (called TGLZMatrix2f, TGZMatrix2i, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>, @TODO:TGLZMatrix4i) Single precision and Integer are only (currently) supported. By default, matrices are stored in row-major order ; column-major order is not supported.    <p>There is also support for Homogenous plane operations and transformations <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a>. And for representing rotations in 3D space, you can use <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a>.    <p>Vectors, matrices and other are not only used to represent points in space, they can also be used as arrays of 2, 3,4,...16 values that can be used to perform calculations in parallel.    <p>You'll equally find,some functions like in shader languages (such as GLSL and HLSL). For example : <br> You can use the the <a class=\"normal\" href=\"GLZMath.html#SmoothStep\">SmoothStep</a>, <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a>, <a class=\"normal\" href=\"GLZMath.html#Sqrt\">Sqrt</a>, (<a class=\"normal\" href=\"GLZMath.html#SinCos\">SinCos</a>)... functions to calculate only a single value, or compute 2 or 4 values at the same time by using it with a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> or <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    <p>All fast math describe in <a class=\"normal\" href=\"GLZFastMath.html\">GLZFastMath</a> unit are prefixed by &quot;Fast&quot; (Except for <a class=\"normal\" href=\"GLZMath.html#Sin\">sin</a>/<a class=\"normal\" href=\"GLZMath.html#Cos\">cos</a> approximations functions).    <p>In <a class=\"normal\" href=\"GLZVectorMathEx.html\">GLZVectorMathEX</a>, you have access to some specifics advanced record for rendering system.<br> You'll can manipulate for 2D or 3D space view : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>Frustum TGLZFrustum </p></li>    <li><p>Oriented Bounding Box (OBB) <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> </p></li>    <li><p>Axis Aligned Bounding Box (AABB) <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> </p></li>    <li><p>bounding sphere <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a></p></li>    <li><p>and use a specialized raycast advanced record TGLZRayCast</p></li>  </ul>    <p>    <p><h2 class=\"\"><span id=\"SecOverloadOps\"></span>Overloaded Operators</h2>      <p>All vector types support overloaded operators which allow you to negate, add, subtract, multiply and divide scalars, vectors . <br> There are also overloaded operators that compare vectors or matrices for equality. The arithmetic operators &quot;+&quot;, &quot;-&quot;, &quot;*&quot; and &quot;/&quot; usually work component-wise when applied to vectors. For compute Cross or Dot used respectively CrossProduct and DotProduct functions    <p>For matrices, the &quot;+&quot;, &quot;-&quot; and special &quot;/&quot; (only divide by a single value) operators operate component-wise. <br> However, when multiplying matrices with vectors or other matrices, then the usual linear algebraic multiplication is used. For example: </p>    <p>( (Matrix := Matrix1 * Matrix2 &ndash;&gt; performs a linear algebraic matrix multiplication (Vector := Matrix1 * Vector1 &ndash;&gt; Transform     <p>To multiply matrices component-wise, you can use the Multiply function instead.    <p><h3 class=\"\"><span id=\"SecOverloadExamples\"></span>Examples</h3>   </p>    <pre class=\"longcode\">  <span class=\"pascal_keyword\">Uses</span> GLZMath, GLZVectorMath, GLZVectorMAthEX;</pre>    <p>    <p><h2 class=\"\"><span id=\"SecHowTo\"></span>How to use Vector Classes Library</h2>      <p>First Copy VectorClasses folder under sub folder of your project    <p>Set your project option folder search path    <p>Add <a class=\"normal\" href=\"GLZVectorMath.html\">GLZVectorMath</a>, <a class=\"normal\" href=\"GLZMath.html\">GLZMath</a>, <a class=\"normal\" href=\"GLZVectorMathEx.html\">GLZVectorMathEX</a> in &quot;uses&quot;    <p><h3 class=\"\"><span id=\"SecHowToExamples\"></span>Examples</h3>   </p>    <pre class=\"longcode\">  <span class=\"pascal_keyword\">Uses</span> GLZMath, GLZVectorMath, GLZVectorMAthEX;</pre>    <p>    <p><h2 class=\"\"><span id=\"SecAlignDatas\"></span>How to align data to 16 bits boundary</h2>   Under x64, for using vector based function, you'll need add some preprocessor commands to get proper aligned data.    <p><h3 class=\"\"><span id=\"SecAlignDatasExamples\"></span>Examples</h3>   On the header of your unit add : <br> </p>    <pre class=\"longcode\">  <span class=\"pascal_keyword\">Unit</span> MyUnit;  <span class=\"pascal_compiler_comment\">{$mode objfpc}</span><span class=\"pascal_compiler_comment\">{$H+}</span>  <span class=\"pascal_compiler_comment\">{$CODEALIGN LOCALMIN=16}</span></pre>    <p> <br> @OrderedLis(       <p><h2 class=\"\"><span id=\"SecSetupPrj\"></span>How to configure your project properly</h2>      <p>You need to know some additionnal options for compiler to configure GLZ-MathsClasses.    <p></p>    <ol class=\"paragraph_spacing\">    <li value=\"1\"><p>Go in project options</p></li>    <li value=\"2\"><p>Go in project extrasoptions</p></li>    <li value=\"3\"><p>Write options in extracfg.cfg</p></li>  </ol>    <p>    <p><h2 class=\"\"><span id=\"SecTGLZVectors\"></span>Routines dealing with 2D,3D and 4D Vectors</h2>      <p><h3 class=\"\"><span id=\"SecTGLZVectorsOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZVectorsExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZMatrix\"></span>Routines dealing with 2D,3D and 4D Matrix</h2>      <p><h3 class=\"\"><span id=\"SecTGLZMatrixOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZMatrixExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZEulerAngles\"></span>Routines dealing with Euler Angles</h2>      <p><h3 class=\"\"><span id=\"SecTGLZEulerAnglesOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZEulerAnglesExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZQuaternion\"></span>Routines dealing with Quaternion</h2>      <p><h3 class=\"\"><span id=\"SecTGLZQuaternionOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZQuaternionExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZHmgPlane\"></span>Routines dealing with Homogenous Plane</h2>      <p><h3 class=\"\"><span id=\"SecTGLZHmgPlaneOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZHmgPlaneExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZFrustum\"></span>Routines dealing with Frustum</h2>      <p><h3 class=\"\"><span id=\"SecTGLZFrustumOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZFrustumExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZOBB\"></span>Routines dealing with Oriented Bounding Box</h2>      <p><h3 class=\"\"><span id=\"SecTGLZOBBOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZOBBExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZAABB\"></span>Routines dealing with Axis Aligned Bounding Box</h2>      <p><h3 class=\"\"><span id=\"SecTGLZAABBOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZAABBExamples\"></span>Examples</h3>      <p><h2 class=\"\"><span id=\"SecTGLZRayCast\"></span>Routines dealing with RayCast</h2>      <p><h3 class=\"\"><span id=\"SecTGLZRayCastOverview\"></span>Overview</h3>      <p><h3 class=\"\"><span id=\"SecTGLZRayCastExamples\"></span>Examples</h3>      <p>Functions Below you will find a categorized list of the global functions supported in GLZ-MathsClasses :    <p>Helper functions for creating vectors and matrices Vector2: creates a 2D vector    <p>Vector3: creates a 3D vector    <p>Vector4: creates a 4D vector    <p>Matrix2: creates a 2x2 matrix    <p>Matrix3: creates a 3x3 matrix    <p>Matrix4: creates a 4x4 matrix    <p>Quaternion: creates a quaternion    <p>IVector2: creates a 2D integer vector    <p>IVector3: creates a 3D integer vector    <p>IVector4: creates a 4D integer vector    <p>Angle and Trigonometry Functions Radians: converts degrees to radians    <p>Degrees: converts radians to degrees    <p><a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a>: calculates a sine of an angle    <p><a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a>: calculates a cosine of an angle    <p><a class=\"normal\" href=\"GLZMath.html#SinCos\">SinCos</a>: calculates a sine/cosine pair    <p><a class=\"normal\" href=\"GLZMath.html#Tan\">Tan</a>: calculates the tangent of an angle    <p><a class=\"normal\" href=\"GLZMath.html#ArcSin\">ArcSin</a>: calculates an arc sine    <p><a class=\"normal\" href=\"GLZMath.html#ArcCos\">ArcCos</a>: calculates an arc cosine    <p>ArcTan: calculates an arc tangent    <p><a class=\"normal\" href=\"GLZMath.html#ArcTan2\">ArcTan2</a>: calculates an arctangent angle and quadrant    <p><a class=\"normal\" href=\"GLZMath.html#Sinh\">Sinh</a>: calculates a hyperbolic sine    <p><a class=\"normal\" href=\"GLZMath.html#Cosh\">Cosh</a>: calculates a hyperbolic cosine    <p>Tanh: calculates a hyperbolic tangent    <p>ArcSinh: calculates an inverse hyperbolic sine    <p>ArcCosh: calculates an inverse hyperbolic cosine    <p>ArcTanh: calculates an inverse hyperbolic tangent    <p>Exponential Functions Power: raises a base to a power    <p><a class=\"normal\" href=\"GLZMath.html#Exp\">Exp</a>: calculates a natural exponentiation (that is, e raised to a given power)    <p><a class=\"normal\" href=\"GLZMath.html#Ln\">Ln</a>: calculates a natural logarithm    <p>Exp2: calculates 2 raised to a power    <p><a class=\"normal\" href=\"GLZMath.html#Log2\">Log2</a>: calculates a base 2 logarithm    <p><a class=\"normal\" href=\"GLZMath.html#Sqrt\">Sqrt</a>: calculates a square root    <p>InverseSqrt: calculates an inverse square root    <p>Fast Approximate Functions FastSin: fast sine function    <p>FastCos: fast cosine function    <p>FastSinCos: fast sine/cosine function    <p><a class=\"normal\" href=\"GLZFastMath.html#FastTan\">FastTan</a>: fast tangent function    <p><a class=\"normal\" href=\"GLZFastMath.html#FastArcTan2\">FastArcTan2</a>: fast arctangent angle and quadrant    <p><a class=\"normal\" href=\"GLZFastMath.html#FastPower\">FastPower</a>: fast power function    <p><a class=\"normal\" href=\"GLZFastMath.html#FastExp\">FastExp</a>: fast natural exponentiation function    <p><a class=\"normal\" href=\"GLZFastMath.html#FastLn\">FastLn</a>: fast natural logarithm function    <p><a class=\"normal\" href=\"GLZFastMath.html#FastLog2\">FastLog2</a>: fast base 2 logarithm function    <p>FastExp2: fast Exp2 function    <p>Common Functions Abs: calculates an absolute value    <p><a class=\"normal\" href=\"GLZMath.html#Sign\">Sign</a>: calculates the <a class=\"normal\" href=\"GLZMath.html#Sign\">sign</a> of a value    <p><a class=\"normal\" href=\"GLZMath.html#Floor\">Floor</a>: rounds a value towards negative infinity    <p><a class=\"normal\" href=\"GLZMath.html#Trunc\">Trunc</a>: rounds a value towards 0    <p><a class=\"normal\" href=\"GLZMath.html#Round\">Round</a>: rounds a value towards its nearest integer    <p><a class=\"normal\" href=\"GLZMath.html#Ceil\">Ceil</a>: rounds a value towards positive infinity    <p>Frac: returns the fractional part of a number    <p>FMod: calculates the remainder of a floating-point division    <p>ModF: splits a floating-point value into its integer and fractional parts    <p><a class=\"normal\" href=\"GLZMath.html#Min\">Min</a>: calculates the minimum of two values    <p><a class=\"normal\" href=\"GLZMath.html#Max\">Max</a>: calculates the maximum of two values    <p>EnsureRange: clamps a given value into a range    <p>Mix: calculates a linear blend between two values, using on a progress value    <p><a class=\"normal\" href=\"GLZMath.html#Step\">Step</a>: <a class=\"normal\" href=\"GLZMath.html#Step\">step</a> function    <p><a class=\"normal\" href=\"GLZMath.html#SmoothStep\">SmoothStep</a>: performs smooth Hermite interpolation between 0 and 1    <p>FMA: Fused Multiply and Add J.Delauney (BeanzMaster)  P.Dyson (Dicped)   Vector Classes Math Librairy for FPC & Lazarus", "tags": "", "loc": "introduction.html"},
     {"title": "GLZFastMath", "text": "====&lt; GLZFastMath.pas &gt;=====================================================<br>  @author(J.Delauney (BeanzMaster) - Peter Dyson (Dicepd) Historique : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>25/11/2017 : Creation </p></li>  </ul>    <p> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; Description : L'unité <a class=\"normal\" href=\"GLZVectorMath.html\">GLZVectorMath</a> regroupe des fonctions mathematiques, optimisées en assembleur SSE/SSE2/SSE3/SSE4 et AVX pour les vecteurs, matrices, quaternion et autres fonctions utiles en 3D &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; <b>Notes :</b>    <p>Quelques liens : </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/\">http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Fast_inverse_square_root\">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Taylor_series\">https://en.wikipedia.org/wiki/Taylor_series</a></p></li>    <li><p><a  href=\"https://stackoverflow.com/questions/18662261/fastest-implementation-of-sine-cosine-and-square-root-in-c-doesnt-need-to-b\">https://stackoverflow.com/questions/18662261/fastest-implementation-of-sine-cosine-and-square-root-in-c-doesnt-need-to-b</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Newton%27s_method\">https://en.wikipedia.org/wiki/Newton%27s_method</a></p></li>    <li><p><a  href=\"http://allenchou.net/2014/02/game-math-faster-sine-cosine-with-polynomial-curves/\">http://allenchou.net/2014/02/game-math-faster-sine-cosine-with-polynomial-curves/</a></p></li>    <li><p><a  href=\"http://www.ue.eti.pg.gda.pl/~wrona/lab_dsp/cw04/fun_aprox.pdf\">http://www.ue.eti.pg.gda.pl/&tilde;wrona/lab_dsp/cw04/fun_aprox.pdf</a></p></li>    <li><p><a  href=\"http://www.netlib.org/cephes/\">http://www.netlib.org/cephes/</a></p></li>    <li><p><a  href=\"http://www.ue.eti.pg.gda.pl/~wrona/lab_dsp/cw04/fun_aprox.pdf\">http://www.ue.eti.pg.gda.pl/&tilde;wrona/lab_dsp/cw04/fun_aprox.pdf</a></p></li>  </ul>    <p> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>    <p><b>Credits :</b> </p>    <ul class=\"paragraph_spacing\">    <li><p>FPC/Lazarus</p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> LICENCE : GPL/MPL <br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; *============================================================================== ", "tags": "", "loc": "GLZFastMath.html"},
     {"title": "GLZFastMath.TaylorCos", "text": "&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; At This Stage just for testing. Unused function will comment in final version and stay for educational purpose &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; Cosinus    ", "tags": "", "loc": "GLZFastMath.html#TaylorCos"},
     {"title": "GLZFastMath.TaylorLambertCos", "text": "    ", "tags": "", "loc": "GLZFastMath.html#TaylorLambertCos"},
     {"title": "GLZFastMath.QuadraticCurveCosLP", "text": "    ", "tags": "", "loc": "GLZFastMath.html#QuadraticCurveCosLP"},
     {"title": "GLZFastMath.QuadraticCurveCosHP", "text": "    ", "tags": "", "loc": "GLZFastMath.html#QuadraticCurveCosHP"},
     {"title": "GLZFastMath.RemezCos", "text": "    ", "tags": "", "loc": "GLZFastMath.html#RemezCos"},
     {"title": "GLZFastMath.TaylorSin", "text": "Sinus    ", "tags": "", "loc": "GLZFastMath.html#TaylorSin"},
     {"title": "GLZFastMath.TaylorLambertSin", "text": "    ", "tags": "", "loc": "GLZFastMath.html#TaylorLambertSin"},
     {"title": "GLZFastMath.QuadraticCurveSinLP", "text": "    ", "tags": "", "loc": "GLZFastMath.html#QuadraticCurveSinLP"},
     {"title": "GLZFastMath.QuadraticCurveSinHP", "text": "    ", "tags": "", "loc": "GLZFastMath.html#QuadraticCurveSinHP"},
     {"title": "GLZFastMath.RemezSin", "text": "    ", "tags": "", "loc": "GLZFastMath.html#RemezSin"},
     {"title": "GLZFastMath.FastCosLUT", "text": "%endregion%    ", "tags": "", "loc": "GLZFastMath.html#FastCosLUT"},
     {"title": "GLZFastMath.FastSinLUT", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastSinLUT"},
     {"title": "GLZFastMath.FastSinc", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastSinc"},
     {"title": "GLZFastMath.FastTan", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastTan"},
     {"title": "GLZFastMath.FastArcTan", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastArcTan"},
     {"title": "GLZFastMath.FastArcTan2", "text": "Fast <a class=\"normal\" href=\"GLZMath.html#ArcTan2\">ArcTan2</a> approximation, about 0.07 rads accuracy.    ", "tags": "", "loc": "GLZFastMath.html#FastArcTan2"},
     {"title": "GLZFastMath.FastArcSine", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastArcSine"},
     {"title": "GLZFastMath.FastArcCosine", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastArcCosine"},
     {"title": "GLZFastMath.FastInvSqrt", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastInvSqrt"},
     {"title": "GLZFastMath.FastSqrt", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastSqrt"},
     {"title": "GLZFastMath.FastLn", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLn"},
     {"title": "GLZFastMath.FastExp", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastExp"},
     {"title": "GLZFastMath.FastLog", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLog"},
     {"title": "GLZFastMath.FastLog2", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLog2"},
     {"title": "GLZFastMath.FastLog10", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLog10"},
     {"title": "GLZFastMath.FastLDExp", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLDExp"},
     {"title": "GLZFastMath.FastLNXP1", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastLNXP1"},
     {"title": "GLZFastMath.FastAbs", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastAbs"},
     {"title": "GLZFastMath.FastNeg", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastNeg"},
     {"title": "GLZFastMath.FastSign", "text": "    ", "tags": "", "loc": "GLZFastMath.html#FastSign"},
     {"title": "GLZFastMath.FastPower", "text": "function <code>FastPower</code>(i:single;n:integer):single;    ", "tags": "", "loc": "GLZFastMath.html#FastPower"},
     {"title": "GLZFastMath._InitSinLUT", "text": "Internals function only use in <a class=\"normal\" href=\"GLZMath.html\">GLZMath</a>. For initialize and Finalize SinLUT for <a class=\"normal\" href=\"GLZFastMath.html#FastSinLUT\">FastSinLUT</a> and <a class=\"normal\" href=\"GLZFastMath.html#FastCosLUT\">FastCosLUT</a> functions    ", "tags": "", "loc": "GLZFastMath.html#_InitSinLUT"},
     {"title": "GLZFastMath._DoneSinLUT", "text": "    ", "tags": "", "loc": "GLZFastMath.html#_DoneSinLUT"},
     {"title": "GLZMath", "text": "====&lt; GLZMath.pas &gt;===========================================================<br>   Historique : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>18/11/2016 : Creation </p></li>  </ul>    <p> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br>    <p>Description : <br> The <code>GLZMath</code> unit containss optimized mathematical functions. <br>   Appoximative functions can be used if desired (useful for real time). <br>    <p>  For example: <br> The 'approximated' functions of <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a> and <a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a> have an average accuracy of 4E-8.    <p>It includes trigonometric functions, calculating interpolations, Advanced features like <a class=\"normal\" href=\"GLZMath.html#Bessel\">Bessel</a>, <a class=\"normal\" href=\"GLZMath.html#Blackman\">BlackMan</a>. And also some useful functions    <p>It also has undefined functions in the FPC Math unit tel <a class=\"normal\" href=\"GLZMath.html#ArcCsc\">ArcCsc</a>, <a class=\"normal\" href=\"GLZMath.html#ArcSec\">ArcSec</a>, <a class=\"normal\" href=\"GLZMath.html#ArcCot\">ArcCot</a>, <a class=\"normal\" href=\"GLZMath.html#CscH\">CscH</a>, <a class=\"normal\" href=\"GLZMath.html#SecH\">SecH</a> ect ... @ br    <p>  For more mathematical functions see units: <br> -     <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; <br> <b>Notes :</b>    <p>Quelques liens : </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"http://www.i-logic.com/utilities/trig.htm\">http://www.i-logic.com/utilities/trig.htm</a></p></li>    <li><p><a  href=\"http://jacksondunstan.com/articles/1217\">http://jacksondunstan.com/articles/1217</a></p></li>    <li><p><a  href=\"http://mathworld.wolfram.com\">http://mathworld.wolfram.com</a></p></li>  </ul>    <p> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>    <p><b>Credits :</b> </p>    <ul class=\"paragraph_spacing\">    <li><p>FPC/Lazarus</p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> LICENCE : GPL/MPL <br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; *============================================================================== J.Delauney (BeanzMaster)  ", "tags": "", "loc": "GLZMath.html"},
     {"title": "GLZMath.TSinCos", "text": "%endregion% ", "tags": "", "loc": "GLZMath.TSinCos.html"},
     {"title": "GLZMath.TSinCos.sin", "text": " ", "tags": "", "loc": "GLZMath.TSinCos.html#sin"},
     {"title": "GLZMath.TSinCos.cos", "text": " ", "tags": "", "loc": "GLZMath.TSinCos.html#cos"},
     {"title": "GLZMath.cInfinity", "text": "Commons usefull Math Constants  ", "tags": "", "loc": "GLZMath.html#cInfinity"},
     {"title": "GLZMath.EpsilonFuzzFactor", "text": " ", "tags": "", "loc": "GLZMath.html#EpsilonFuzzFactor"},
     {"title": "GLZMath.EpsilonXTResolution", "text": " ", "tags": "", "loc": "GLZMath.html#EpsilonXTResolution"},
     {"title": "GLZMath.cPI", "text": " ", "tags": "", "loc": "GLZMath.html#cPI"},
     {"title": "GLZMath.cInvPI", "text": "3.141592654; ", "tags": "", "loc": "GLZMath.html#cInvPI"},
     {"title": "GLZMath.c2DivPI", "text": " ", "tags": "", "loc": "GLZMath.html#c2DivPI"},
     {"title": "GLZMath.cPIdiv180", "text": " ", "tags": "", "loc": "GLZMath.html#cPIdiv180"},
     {"title": "GLZMath.cPI180", "text": " ", "tags": "", "loc": "GLZMath.html#cPI180"},
     {"title": "GLZMath.c180divPI", "text": " ", "tags": "", "loc": "GLZMath.html#c180divPI"},
     {"title": "GLZMath.c2PI", "text": " ", "tags": "", "loc": "GLZMath.html#c2PI"},
     {"title": "GLZMath.cPIdiv2", "text": "5286766559; ", "tags": "", "loc": "GLZMath.html#cPIdiv2"},
     {"title": "GLZMath.cPIdiv4", "text": " ", "tags": "", "loc": "GLZMath.html#cPIdiv4"},
     {"title": "GLZMath.c3PIdiv2", "text": " ", "tags": "", "loc": "GLZMath.html#c3PIdiv2"},
     {"title": "GLZMath.c3PIdiv4", "text": " ", "tags": "", "loc": "GLZMath.html#c3PIdiv4"},
     {"title": "GLZMath.cInv2PI", "text": " ", "tags": "", "loc": "GLZMath.html#cInv2PI"},
     {"title": "GLZMath.cInv360", "text": " ", "tags": "", "loc": "GLZMath.html#cInv360"},
     {"title": "GLZMath.c180", "text": " ", "tags": "", "loc": "GLZMath.html#c180"},
     {"title": "GLZMath.c360", "text": " ", "tags": "", "loc": "GLZMath.html#c360"},
     {"title": "GLZMath.cOneHalf", "text": " ", "tags": "", "loc": "GLZMath.html#cOneHalf"},
     {"title": "GLZMath.cMinusOneHalf", "text": " ", "tags": "", "loc": "GLZMath.html#cMinusOneHalf"},
     {"title": "GLZMath.cOneDotFive", "text": " ", "tags": "", "loc": "GLZMath.html#cOneDotFive"},
     {"title": "GLZMath.cZero", "text": " ", "tags": "", "loc": "GLZMath.html#cZero"},
     {"title": "GLZMath.cOne", "text": " ", "tags": "", "loc": "GLZMath.html#cOne"},
     {"title": "GLZMath.cLn10", "text": " ", "tags": "", "loc": "GLZMath.html#cLn10"},
     {"title": "GLZMath.cEpsilon", "text": " ", "tags": "", "loc": "GLZMath.html#cEpsilon"},
     {"title": "GLZMath.cEpsilon40", "text": " ", "tags": "", "loc": "GLZMath.html#cEpsilon40"},
     {"title": "GLZMath.cEpsilon30", "text": " ", "tags": "", "loc": "GLZMath.html#cEpsilon30"},
     {"title": "GLZMath.cFullEpsilon", "text": " ", "tags": "", "loc": "GLZMath.html#cFullEpsilon"},
     {"title": "GLZMath.cColinearBias", "text": " ", "tags": "", "loc": "GLZMath.html#cColinearBias"},
     {"title": "GLZMath.cEulerNumber", "text": " ", "tags": "", "loc": "GLZMath.html#cEulerNumber"},
     {"title": "GLZMath.cInvSqrt2", "text": " ", "tags": "", "loc": "GLZMath.html#cInvSqrt2"},
     {"title": "GLZMath.cInvThree", "text": " ", "tags": "", "loc": "GLZMath.html#cInvThree"},
     {"title": "GLZMath.cInv255", "text": " ", "tags": "", "loc": "GLZMath.html#cInv255"},
     {"title": "GLZMath.MinSingle", "text": "portées maximal les types de points flottants IEEE Compatible avec Math.pas ", "tags": "", "loc": "GLZMath.html#MinSingle"},
     {"title": "GLZMath.MaxSingle", "text": " ", "tags": "", "loc": "GLZMath.html#MaxSingle"},
     {"title": "GLZMath.MinDouble", "text": " ", "tags": "", "loc": "GLZMath.html#MinDouble"},
     {"title": "GLZMath.MaxDouble", "text": " ", "tags": "", "loc": "GLZMath.html#MaxDouble"},
     {"title": "GLZMath.MinExtended", "text": " ", "tags": "", "loc": "GLZMath.html#MinExtended"},
     {"title": "GLZMath.MaxExtended", "text": " ", "tags": "", "loc": "GLZMath.html#MaxExtended"},
     {"title": "GLZMath.MinComp", "text": "Complex ", "tags": "", "loc": "GLZMath.html#MinComp"},
     {"title": "GLZMath.MaxComp", "text": " ", "tags": "", "loc": "GLZMath.html#MaxComp"},
     {"title": "GLZMath.Round", "text": "<code>Round</code> : Rounds a value towards its nearest integer    V value to <code>round</code> Rounded value V value to <code>round</code>", "tags": "", "loc": "GLZMath.html#Round"},
     {"title": "GLZMath.Trunc", "text": "<code>Trunc</code> : Rounds a value towards 0    V : Value to <code>trunc</code> Truncated value V : Value to <code>trunc</code>", "tags": "", "loc": "GLZMath.html#Trunc"},
     {"title": "GLZMath.Floor", "text": "<code>Floor</code> : Rounds a value towards negative infinity    v : value to <code>floor</code> Floored value v : value to <code>floor</code>", "tags": "", "loc": "GLZMath.html#Floor"},
     {"title": "GLZMath.Fract", "text": "<code>Fract</code> : Returns the fractional part of a number    v value where extract fractionnal part Fractionnal part v value where extract fractionnal part", "tags": "", "loc": "GLZMath.html#Fract"},
     {"title": "GLZMath.Ceil", "text": "<code>Ceil</code> : Rounds a value towards positive infinity    v : value to <code>ceil</code> Ceilled value v : value to <code>ceil</code>", "tags": "", "loc": "GLZMath.html#Ceil"},
     {"title": "GLZMath.fmodf", "text": "<code>fmodf</code> : calculates the remainder of a floating-point division     A : Number to divide A : Divisor remainder in floating point A : Number to divide A : Divisor", "tags": "", "loc": "GLZMath.html#fmodf"},
     {"title": "GLZMath.Clamp", "text": "<code>Clamp</code> : Clamps a given value into a range of two Integer values      V : Value to compare Min : <a class=\"normal\" href=\"GLZMath.html#Clamp\">Clamp</a> to Minimum Max : <a class=\"normal\" href=\"GLZMath.html#Clamp\">Clamp</a> to Maximum Value ensured in range [<a class=\"normal\" href=\"GLZMath.html#Min\">min</a>..max] V : Value to compare Min : <a class=\"normal\" href=\"GLZMath.html#Clamp\">Clamp</a> to Minimum Max : <a class=\"normal\" href=\"GLZMath.html#Clamp\">Clamp</a> to Maximum", "tags": "", "loc": "GLZMath.html#Clamp"},
     {"title": "GLZMath.Clamp", "text": "<code>Clamp</code> : Clamps a given value into a range of two Single values      V : Value to compare Min : <code>Clamp</code> to Minimum Max : <code>Clamp</code> to Maximum Value ensured in range [<a class=\"normal\" href=\"GLZMath.html#Min\">min</a>..max] V : Value to compare Min : <code>Clamp</code> to Minimum Max : <code>Clamp</code> to Maximum", "tags": "", "loc": "GLZMath.html#Clamp"},
     {"title": "GLZMath.ClampByte", "text": "<code>ClampByte</code> : Clamps a given value into a range of 0..255    V : Value to compare Value ensured in ragne [0..255] V : Value to compare", "tags": "", "loc": "GLZMath.html#ClampByte"},
     {"title": "GLZMath.IsZero", "text": "<code>IsZero</code> : Check if value is near zero or absolute zero     A : Value to test Epsilon : Précision test, default absolute zero = 0.0 <code>True</code> if equal or less than Epsilon. <code>False</code> otherwise A : Value to test Epsilon : Précision test, default absolute zero = 0.0", "tags": "", "loc": "GLZMath.html#IsZero"},
     {"title": "GLZMath.Sign", "text": "<code>Sign</code> : Returns the <code>sign</code> of the x value using the (-1, 0, +1) convention    X : Value to get <code>sign</code> <code>Sign</code> : </p>    <ul class=\"paragraph_spacing\">    <li><p>-1 : Less than zero</p></li>    <li><p> 0 : Equal to zero</p></li>    <li><p>+1 : Greater than zero</p></li>  </ul>    <p> X : Value to get <code>sign</code>", "tags": "", "loc": "GLZMath.html#Sign"},
     {"title": "GLZMath.SignStrict", "text": "<code>SignStrict</code> : Returns the strict <a class=\"normal\" href=\"GLZMath.html#Sign\">sign</a> of the x value using the (-1, +1) convention  )   X : Value to get Strict <a class=\"normal\" href=\"GLZMath.html#Sign\">sign</a> Strict <a class=\"normal\" href=\"GLZMath.html#Sign\">Sign</a> : </p>    <ul class=\"paragraph_spacing\">    <li><p>-1 : Less than zero</p></li>    <li><p>+1 : Equal or Greater than zero</p></li>  </ul>    <p> X : Value to get Strict <a class=\"normal\" href=\"GLZMath.html#Sign\">sign</a>", "tags": "", "loc": "GLZMath.html#SignStrict"},
     {"title": "GLZMath.RoundInt", "text": "<code>RoundInt</code> : Rounds the floating point value to the closest Integer. <br> Behaves like <a class=\"normal\" href=\"GLZMath.html#Round\">Round</a> but returns a floating point value like Int.    v : value to <a class=\"normal\" href=\"GLZMath.html#Round\">round</a> Rounded value v : value to <a class=\"normal\" href=\"GLZMath.html#Round\">round</a>", "tags": "", "loc": "GLZMath.html#RoundInt"},
     {"title": "GLZMath.NewRound", "text": "<code>NewRound</code> : rounds a value towards its nearest integer  @return      ", "tags": "", "loc": "GLZMath.html#NewRound"},
     {"title": "GLZMath.Max", "text": "<code>Max</code> : Returns the maximum of three integer values      A : value 1 B : value 2 C : value 3 The maximum value A : value 1 B : value 2 C : value 3", "tags": "", "loc": "GLZMath.html#Max"},
     {"title": "GLZMath.Min", "text": "<code>Min</code> : Returns the minimum of three integer values      A : value 1 B : value 2 C : value 3 The minimum value A : value 1 B : value 2 C : value 3", "tags": "", "loc": "GLZMath.html#Min"},
     {"title": "GLZMath.Max", "text": "<code>Max</code> : Returns the maximum of two values     v1 : value 1 v2 : value 2 The maximum value v1 : value 1 v2 : value 2", "tags": "", "loc": "GLZMath.html#Max"},
     {"title": "GLZMath.Min", "text": "<code>Min</code> : Returns the minimum of two values     v1 : value 1 v2 : value 2 The minimum value v1 : value 1 v2 : value 2", "tags": "", "loc": "GLZMath.html#Min"},
     {"title": "GLZMath.Max", "text": "<code>Max</code> : calculates the maximum of three single values      A : value 1 B : value 2 C : value 3 The maximum value A : value 1 B : value 2 C : value 3", "tags": "", "loc": "GLZMath.html#Max"},
     {"title": "GLZMath.Min", "text": "<code>Min</code> : calculates the minimum of three single values      A : value 1 B : value 2 C : value 3 The minimum value A : value 1 B : value 2 C : value 3", "tags": "", "loc": "GLZMath.html#Min"},
     {"title": "GLZMath.ComputeReciprocal", "text": "<code>ComputeReciprocal</code> : Compute Reciprocal (1 / x)    x : value to get reciprocal Reciprocal x : value to get reciprocal", "tags": "", "loc": "GLZMath.html#ComputeReciprocal"},
     {"title": "GLZMath.IsInRange", "text": "<code>IsInRange</code> : rounds a value towards its nearest integer      X : value to test A : minimum range value B : maximum range value <code>True</code> if in range [a..b]. <code>False</code> otherwise X : value to test A : minimum range value B : maximum range value", "tags": "", "loc": "GLZMath.html#IsInRange"},
     {"title": "GLZMath.NormalizeRadAngle", "text": "<code>NormalizeRadAngle</code> : Normalize angle in radian    Angle : Value in radian to normalize Normalized value Angle : Value in radian to normalize", "tags": "", "loc": "GLZMath.html#NormalizeRadAngle"},
     {"title": "GLZMath.NormalizeDegAngle", "text": "<code>NormalizeDegAngle</code> : Normalize angle in degree    Angle : Value in degree to normalize Normalized value Angle : Value in degree to normalize", "tags": "", "loc": "GLZMath.html#NormalizeDegAngle"},
     {"title": "GLZMath.DistanceBetweenAngles", "text": "<code>DistanceBetweenAngles</code> : Compute distance between two angle     Angle1 : Value 1 in degree Angle2 : Value 2 in degree Distance between Angle1 and Angle2 Angle1 : Value 1 in degree Angle2 : Value 2 in degree", "tags": "", "loc": "GLZMath.html#DistanceBetweenAngles"},
     {"title": "GLZMath.DegToRadian", "text": "<code>DegToRadian</code> : converts degrees to radians (Degrees : Angle to convert in degrees     Converted value as Radian  ", "tags": "", "loc": "GLZMath.html#DegToRadian"},
     {"title": "GLZMath.RadianToDeg", "text": "<code>RadianToDeg</code> : converts radians to degrees (Degrees : Angle to convert in Radian     Converted value as Degrees  ", "tags": "", "loc": "GLZMath.html#RadianToDeg"},
     {"title": "GLZMath.InterpolateAngleLinear", "text": "<code>InterpolateAngleLinear</code> : Linear interpolation between angle      Start : Start Angle Stop : Stop Angle t : Current <a class=\"normal\" href=\"GLZMath.html#Step\">step</a> in range [0..1] Interpolated value Start : Start Angle Stop : Stop Angle t : Current <a class=\"normal\" href=\"GLZMath.html#Step\">step</a> in range [0..1]", "tags": "", "loc": "GLZMath.html#InterpolateAngleLinear"},
     {"title": "GLZMath.IsPowerOfTwo", "text": "<code>IsPowerOfTwo</code> : Returns if value is a power of two.    Value : Value to test <code>True</code> if the specified value is a power of two or <code>False</code> otherwise Value : Value to test", "tags": "", "loc": "GLZMath.html#IsPowerOfTwo"},
     {"title": "GLZMath.NextPowerOfTwo", "text": "<code>NextPowerOfTwo</code> : Returns next power of two fro m value    Value : Value reference Next power of two Value : Value reference", "tags": "", "loc": "GLZMath.html#NextPowerOfTwo"},
     {"title": "GLZMath.PreviousPowerOfTwo", "text": "<code>PreviousPowerOfTwo</code> : Returns previous power of two fro m value    Value : Value reference Previous power of two Value : Value reference", "tags": "", "loc": "GLZMath.html#PreviousPowerOfTwo"},
     {"title": "GLZMath.Pow", "text": "<code>Pow</code> : Raise base to any power. For fractional exponents, or |exponents| &gt; MaxInt, base must be &gt; 0.     Base : Base Exponent : Exponent Single float precision Raise Base to Exponent power Base : Base Exponent : Exponent", "tags": "", "loc": "GLZMath.html#Pow"},
     {"title": "GLZMath.PowerInteger", "text": "<code>PowerInteger</code> : Raise float single precision base to Integer power     Base : Base Exponent : Exponent Single float precision Raise Base to Exponent power Base : Base Exponent : Exponent", "tags": "", "loc": "GLZMath.html#PowerInteger"},
     {"title": "GLZMath.PowerInt", "text": "<code>PowerInt</code> : Raise Integer base to Integer power     Base : Base Exponent : Exponent Single float precision Raise Base to Exponent power Base : Base Exponent : Exponent", "tags": "", "loc": "GLZMath.html#PowerInt"},
     {"title": "GLZMath.pow3", "text": "<code>pow3</code> : Raise base to power of 3    X : Base Base raise by 3 X : Base", "tags": "", "loc": "GLZMath.html#pow3"},
     {"title": "GLZMath.Sin", "text": "<code>Sin</code> : Calculates sine from the given angle X    X : Angle in radian Single float precision Sine X : Angle in radian", "tags": "", "loc": "GLZMath.html#Sin"},
     {"title": "GLZMath.Cos", "text": "<code>Cos</code> : Calculates cosine from the given angle X    X : Angle in radian Single float precision Cosine X : Angle in radian", "tags": "", "loc": "GLZMath.html#Cos"},
     {"title": "GLZMath.Tan", "text": "<code>Tan</code> : calculates the tangent of an angle    X : Angle in radian Single float precision Tangent X : Angle in radian", "tags": "", "loc": "GLZMath.html#Tan"},
     {"title": "GLZMath.SinCos", "text": "<code>SinCos</code> : Calculates sine and cosine from the given angle Theta  @return(@unorderedlis(    Theta in radian  Theta in radian", "tags": "", "loc": "GLZMath.html#SinCos"},
     {"title": "GLZMath.SinCos", "text": "<code>SinCos</code> : Calculates sine and cosine from the given angle Theta and Radius. <br> <a class=\"normal\" href=\"GLZMath.html#Sin\">sin</a> and <a class=\"normal\" href=\"GLZMath.html#Cos\">cos</a> values calculated from theta are multiplicated by radius.   @return(@unorderedlis(    Theta : Angle in radian Radius : factor  Theta : Angle in radian Radius : factor", "tags": "", "loc": "GLZMath.html#SinCos"},
     {"title": "GLZMath.Hypot", "text": "<code>Hypot</code> : Compute the Hypotenuse     X : Value Y : Value Hypotenus X : Value Y : Value", "tags": "", "loc": "GLZMath.html#Hypot"},
     {"title": "GLZMath.CoTan", "text": "<code>CoTan</code> : Calculates cotangent from the given angle X    X : Angle in radian Single float precision Cotangent X : Angle in radian", "tags": "", "loc": "GLZMath.html#CoTan"},
     {"title": "GLZMath.ArcCos", "text": "<code>ArcCos</code> : calculates an arc cosine    X : Angle in radian Single float precision Inverse Cosine X : Angle in radian", "tags": "", "loc": "GLZMath.html#ArcCos"},
     {"title": "GLZMath.ArcSin", "text": "<code>ArcSin</code> : calculates an arc sine    X : Angle in radian Single float precision Inverse Sine X : Angle in radian", "tags": "", "loc": "GLZMath.html#ArcSin"},
     {"title": "GLZMath.ArcTan2", "text": "<code>ArcTan2</code> : calculates an arctangent for angle and quadrant     X : Angle in radian Y : Quadrant Single float precision Inverse Tangent X : Angle in radian Y : Quadrant", "tags": "", "loc": "GLZMath.html#ArcTan2"},
     {"title": "GLZMath.ArcCsc", "text": "<code>ArcCsc</code> : Calculates Inverse Cosecant from the given value    X : Value Single float precision Inverse Cosecant X : Value", "tags": "", "loc": "GLZMath.html#ArcCsc"},
     {"title": "GLZMath.ArcSec", "text": "<code>ArcSec</code> : Calculates Inverse Secant from the given value    X : Value Single float precision Inverse Secant X : Value", "tags": "", "loc": "GLZMath.html#ArcSec"},
     {"title": "GLZMath.ArcCot", "text": "<code>ArcCot</code> : Calculates Inverse Cotangent from the given value    X : Value Single float precision Inverse Cotangent X : Value", "tags": "", "loc": "GLZMath.html#ArcCot"},
     {"title": "GLZMath.Sinh", "text": "<code>Sinh</code> : calculates a hyperbolic sine    X : Value Single float precision Hyperbolic Sine X : Value", "tags": "", "loc": "GLZMath.html#Sinh"},
     {"title": "GLZMath.Cosh", "text": "<code>Cosh</code> : calculates a hyperbolic cosine    X : Value Single float precision Hyperbolic Cosine X : Value", "tags": "", "loc": "GLZMath.html#Cosh"},
     {"title": "GLZMath.CscH", "text": "<code>CscH</code> : calculates a hyperbolic cosecant    X : Value Single float precision Hyperbolic Cosecant X : Value", "tags": "", "loc": "GLZMath.html#CscH"},
     {"title": "GLZMath.SecH", "text": "<code>SecH</code> : calculates a hyperbolic Secant    X : Value Single float precision Hyperbolic Secant X : Value", "tags": "", "loc": "GLZMath.html#SecH"},
     {"title": "GLZMath.CotH", "text": "<code>CotH</code> : calculates a hyperbolic Cotangent    X : Value Single float precision Hyperbolic Cotangent X : Value", "tags": "", "loc": "GLZMath.html#CotH"},
     {"title": "GLZMath.SinCosh", "text": "<code>SinCosh</code> : calculates a hyperbolic Sine/Cosine    X : Value Single float precision Hyperbolic Sine/Cosine X : Value", "tags": "", "loc": "GLZMath.html#SinCosh"},
     {"title": "GLZMath.ArcCscH", "text": "<code>ArcCscH</code> : calculates a Inverse hyperbolic CoSecant    X : Value Single float precision Inverse Hyperbolic CoSecant X : Value", "tags": "", "loc": "GLZMath.html#ArcCscH"},
     {"title": "GLZMath.ArcSecH", "text": "<code>ArcSecH</code> : calculates a Inverse hyperbolic Secant    X : Value Single float precision Inverse Hyperbolic Secant X : Value", "tags": "", "loc": "GLZMath.html#ArcSecH"},
     {"title": "GLZMath.ArcCotH", "text": "<code>ArcCotH</code> : calculates a Inverse hyperbolic CoTangent    X : Value Single float precision Inverse Hyperbolic CoTangent X : Value", "tags": "", "loc": "GLZMath.html#ArcCotH"},
     {"title": "GLZMath.Sqrt", "text": "<code>Sqrt</code> : calculates square root    A : Value Squared root value A : Value", "tags": "", "loc": "GLZMath.html#Sqrt"},
     {"title": "GLZMath.InvSqrt", "text": "<code>InvSqrt</code> : calculates an inverse square root    v : Value Inverse Squared root value v : Value", "tags": "", "loc": "GLZMath.html#InvSqrt"},
     {"title": "GLZMath.Log2", "text": "<code>Log2</code> : calculates a base 2 logarithm    X : Value <code>Log2</code> value X : Value", "tags": "", "loc": "GLZMath.html#Log2"},
     {"title": "GLZMath.Log10", "text": "<code>Log10</code> : calculates a base 10 logarithm    X : Value <code>Log10</code> value X : Value", "tags": "", "loc": "GLZMath.html#Log10"},
     {"title": "GLZMath.LogN", "text": "<code>LogN</code> : calculates a base N logarithm     Base : Value N : Value Log N value Base : Value N : Value", "tags": "", "loc": "GLZMath.html#LogN"},
     {"title": "GLZMath.Exp", "text": "<code>Exp</code> : calculates a natural exponentiation    X : Value <code>Exp</code> value X : Value", "tags": "", "loc": "GLZMath.html#Exp"},
     {"title": "GLZMath.ldExp", "text": "<code>ldExp</code> : multiplies x by 2 power of n.     X : Value N : Exponent <a class=\"normal\" href=\"GLZMath.html#Exp\">Exp</a> value X : Value N : Exponent", "tags": "", "loc": "GLZMath.html#ldExp"},
     {"title": "GLZMath.Ln", "text": "<code>Ln</code> : calculates a natural logarithm    X : Value Logarithmic value X : Value", "tags": "", "loc": "GLZMath.html#Ln"},
     {"title": "GLZMath.LnXP1", "text": "<code>LnXP1</code> : Return <a class=\"normal\" href=\"GLZMath.html#Ln\">ln</a>(1 + X), accurate for X near 0.    X : Value Logarithmic XP1 value X : Value", "tags": "", "loc": "GLZMath.html#LnXP1"},
     {"title": "GLZMath.BesselOrderOne", "text": "<code>BesselOrderOne</code> : Compute <a class=\"normal\" href=\"GLZMath.html#Bessel\">Bessel</a> Order Onefactor    X : Value <a class=\"normal\" href=\"GLZMath.html#Bessel\">Bessel</a> Order One Double float precicion X : Value", "tags": "", "loc": "GLZMath.html#BesselOrderOne"},
     {"title": "GLZMath.Bessel", "text": "<code>Bessel</code> : Compute <code>Bessel</code> factor    X : Value <code>Bessel</code> Double float precicion X : Value", "tags": "", "loc": "GLZMath.html#Bessel"},
     {"title": "GLZMath.BesselIO", "text": "<code>BesselIO</code> : Compute <a class=\"normal\" href=\"GLZMath.html#Bessel\">Bessel</a> IO factor    X : Value <a class=\"normal\" href=\"GLZMath.html#Bessel\">Bessel</a> IO Double float precicion X : Value", "tags": "", "loc": "GLZMath.html#BesselIO"},
     {"title": "GLZMath.Blackman", "text": "<code>Blackman</code> : Compute <code>Blackman</code> factor    X : Value <code>Blackman</code> Double float precicion X : Value", "tags": "", "loc": "GLZMath.html#Blackman"},
     {"title": "GLZMath.Sinc", "text": "<code>Sinc</code> : A phase shifter <code>sinc</code> curve can be useful if it starts at zero and ends at zero, for some bouncing behaviors (suggested by Hubert-Jan). Give k different integer values to tweak the amount of bounces. It peaks at 1.0, but that take negative values, which can make it unusable in some applications    X : Value <code>Sinc</code> Single float precision X : Value", "tags": "", "loc": "GLZMath.html#Sinc"},
     {"title": "GLZMath.InterpolateValue", "text": "<code>InterpolateValue</code> : Do the same as &quot;<a class=\"normal\" href=\"GLZMath.html#Lerp\">Lerp</a>&quot;, but add some distortions.      )   Start : Start Value Stop : Stop Value Delta : Delta Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation. Interpolated value at Delta Start : Start Value Stop : Stop Value Delta : Delta Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation.", "tags": "", "loc": "GLZMath.html#InterpolateValue"},
     {"title": "GLZMath.InterpolateValueFast", "text": "<code>InterpolateValueFast</code> : Do the same as &quot;<a class=\"normal\" href=\"GLZMath.html#Lerp\">Lerp</a>&quot;, but add some distortions, fast        )   OriginalStart : Start Value OriginalStop : Stop Value OriginalCurrent : Delta Value TargetStart : Start Value TargetStop : Stop Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation. Interpolated value at Delta OriginalStart : Start Value OriginalStop : Stop Value OriginalCurrent : Delta Value TargetStart : Start Value TargetStop : Stop Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation.", "tags": "", "loc": "GLZMath.html#InterpolateValueFast"},
     {"title": "GLZMath.InterpolateValueSafe", "text": "<code>InterpolateValueSafe</code> : Do the same as &quot;<a class=\"normal\" href=\"GLZMath.html#Lerp\">Lerp</a>&quot;, but add some distortions, values are checked        )   OriginalStart : Start Value OriginalStop : Stop Value OriginalCurrent : Delta Value TargetStart : Start Value TargetStop : Stop Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation. Interpolated value at Delta OriginalStart : Start Value OriginalStop : Stop Value OriginalCurrent : Delta Value TargetStart : Start Value TargetStop : Stop Value Distortion : Distortion Value in degree InterpolationType : Kind of interpolation.", "tags": "", "loc": "GLZMath.html#InterpolateValueSafe"},
     {"title": "GLZMath.SmoothStep", "text": "<code>SmoothStep</code> :Perform Hermite interpolation between two values      Edge0 : Start Value Edge1 : Stop Value X : Position Value Smoothed value Edge0 : Start Value Edge1 : Stop Value X : Position Value", "tags": "", "loc": "GLZMath.html#SmoothStep"},
     {"title": "GLZMath.Lerp", "text": "<code>Lerp</code> : Perform linear interpolation between two values      Edge0 : Start Value Edge1 : Stop Value X : Position Value <code>Lerp</code> value Edge0 : Start Value Edge1 : Stop Value X : Position Value", "tags": "", "loc": "GLZMath.html#Lerp"},
     {"title": "GLZMath.Step", "text": "<code>Step</code> : Generate a <code>step</code> function by comparing two values     Edge : Value 1 X : Value 2 0.0 is returned if x &lt; edge, and 1.0 is returned otherwise Edge : Value 1 X : Value 2", "tags": "", "loc": "GLZMath.html#Step"},
     {"title": "GLZMath.Length1D", "text": "<code>Length1D</code> : Return the lenght of vector 1D    X : Value Length of X X : Value", "tags": "", "loc": "GLZMath.html#Length1D"},
     {"title": "GLZMath.AlmostIdentity", "text": "<code>AlmostIdentity</code> : blend value with threshold, and smooth it with a cubic polynomial.   (N : Value things will take when X is zero.    X : Value to Blend M : Thresold   Smoothed value X : Value to Blend M : Thresold  ", "tags": "", "loc": "GLZMath.html#AlmostIdentity"},
     {"title": "GLZMath.Impulse", "text": "<code>Impulse</code> : Great for triggering behaviours or making envelopes for music or animation      K :control the stretching X : A Value Smoothed Value K :control the stretching X : A Value", "tags": "", "loc": "GLZMath.html#Impulse"},
     {"title": "GLZMath.CubicPulse", "text": "<code>CubicPulse</code> : Cubic interpolation. Same as <a class=\"normal\" href=\"GLZMath.html#SmoothStep\">smoothstep</a>(c-w,c,x)-<a class=\"normal\" href=\"GLZMath.html#SmoothStep\">smoothstep</a>(c,c+w,x)<br> You can use it as a cheap replacement for a gaussian       C : Value W : Value X : Value to smoothed Smoothed Value C : Value W : Value X : Value to smoothed", "tags": "", "loc": "GLZMath.html#CubicPulse"},
     {"title": "GLZMath.ExpStep", "text": "<code>ExpStep</code> : A natural attenuation       X : Value to smoothed K : Limit Value N : Power exponent Smoothed Value X : Value to smoothed K : Limit Value N : Power exponent", "tags": "", "loc": "GLZMath.html#ExpStep"},
     {"title": "GLZMath.Parabola", "text": "<code>Parabola</code> : Remap the 0..1 interval into 0..1, such that the corners are remapped to 0 and the center to 1 <br> <b>Note : </b> <code>parabola</code>(0) = <code>parabola</code>(1) = 0, and <code>parabola</code>(1/2) = 1      X : Value N : Power exponent Smoothed Value X : Value N : Power exponent", "tags": "", "loc": "GLZMath.html#Parabola"},
     {"title": "GLZMath.pcurve", "text": "<code>pcurve</code> : Remap the 0..1 interval into 0..1, such that the corners are remapped to 0. <br> Very useful to skew the shape one side or the other in order to make leaves, eyes, and many other interesting shapes       X : Value A : Value B : Value Curved Value X : Value A : Value B : Value", "tags": "", "loc": "GLZMath.html#pcurve"},
     {"title": "GLZMath.pGain", "text": "<code>pGain</code> : Remapping the unit interval into the unit interval by expanding the sides and compressing the center, and keeping 1/2 mapped to 1/2 <br> This was a common function in RSL tutorials (the Renderman Shading Language).  (K :k=1 is the identity curve, k&lt;1 produces the classic gain() shape, and k&gt;1 produces &quot;s&quot; shaped curces. <br> <b>Note : </b> The curves are symmetric (and inverse) for k=a and k=1/a.    X : Value   Curved value X : Value  ", "tags": "", "loc": "GLZMath.html#pGain"},
     {"title": "GLZMath.pSinc", "text": "<code>pSinc</code> : A phase shifter <a class=\"normal\" href=\"GLZMath.html#Sinc\">sinc</a> curve       X : Value K : Value Curved value X : Value K : Value", "tags": "", "loc": "GLZMath.html#pSinc"},
     {"title": "GLZMath.Val2Percent", "text": "<code>Val2Percent</code> : Convert a value to percent from range of [<a class=\"normal\" href=\"GLZMath.html#Min\">min</a>..max]      Min : Minimum value Val : Value to get percent Min : Maximum value Percent Min : Minimum value Val : Value to get percent Min : Maximum value", "tags": "", "loc": "GLZMath.html#Val2Percent"},
     {"title": "GLZMath.PSinCos", "text": " ", "tags": "", "loc": "GLZMath.html#PSinCos"},
     {"title": "GLZMath.TGLZInterpolationType", "text": "Type of interpolation.   itLinear    itPower    itSin    itSinAlt    itTan    itLn    itExp   ", "tags": "", "loc": "GLZMath.html#TGLZInterpolationType"},
     {"title": "GLZVectorMath", "text": "====&lt; GLZVectorMath.pas &gt;=====================================================<br>    <p>      <p>Historique : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>Last Update : 13/03/2018 </p></li>    <li><p>25/11/2017 : Creation </p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> Description :<br> <code>GLZVectorMath</code> is an optimized vector classes math library for FreePascal and Lazarus<br> using SIMD (SSE, SSE3, SS4, AVX, AVX2) acceleration<br> It can be used in 2D/3D graphics, computing apps.<br>    <p>Support :<br> </p>    <p>          )    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> <b>Notes :</b><br>    <p>Notice, here, we need to set rounding FPC mode to is the same as our SSE code.<br> In FPC, the &quot;function <a class=\"normal\" href=\"GLZMath.html#Round\">Round</a>&quot; using &quot;banker's rounding&quot; algorithm.<br> In fat, is not doing a RoundUp or RoundDown if the is exactly x.50<br> Examples : <br> <code><a class=\"normal\" href=\"GLZMath.html#Round\">Round</a>(2.5) //return = 2</code><br> <code><a class=\"normal\" href=\"GLZMath.html#Round\">Round</a>(3.5) //return = 4</code> <br>    <p>For more informations see : <a  href=\"https://www.freepascal.org/docs-html/rtl/system/round.html\">https://www.freepascal.org/docs-html/rtl/system/round.html</a> <br>    <p>Some links as references :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"http://forum.lazarus.freepascal.org/index.php/topic,32741.0.html\">http://forum.lazarus.freepascal.org/index.php/topic,32741.0.html</a></p></li>    <li><p><a  href=\"http://agner.org/optimize/\">http://agner.org/optimize/</a></p></li>    <li><p><a  href=\"http://www.songho.ca/misc/sse/sse.html\">http://www.songho.ca/misc/sse/sse.html</a></p></li>    <li><p><a  href=\"https://godbolt.org\">https://godbolt.org</a></p></li>    <li><p><a  href=\"http://softpixel.com/~cwright/programming/simd/sse.php\">http://softpixel.com/&tilde;cwright/programming/simd/sse.php</a></p></li>    <li><p><a  href=\"https://www.gamasutra.com/view/feature/132636/designing_fast_crossplatform_simd_.php?page=3\">https://www.gamasutra.com/view/feature/132636/designing_fast_crossplatform_simd_.php?page=3</a></p></li>    <li><p><a  href=\"https://butterflyofdream.wordpress.com/2016/07/05/converting-rotation-matrices-of-left-handed-coordinate-system/\">https://butterflyofdream.wordpress.com/2016/07/05/converting-rotation-matrices-of-left-handed-coordinate-system/</a></p></li>    <li><p><a  href=\"http://shybovycha.tumblr.com/post/122400740651/speeding-up-algorithms-with-sse\">http://shybovycha.tumblr.com/post/122400740651/speeding-up-algorithms-with-sse</a></p></li>    <li><p><a  href=\"https://www.scratchapixel.com/index.php\">https://www.scratchapixel.com/index.php</a></p></li>    <li><p><a  href=\"http://mark.masmcode.com\">http://mark.masmcode.com</a></p></li>    <li><p><a  href=\"https://www.cs.uaf.edu/courses/cs441/notes/sse-avx/\">https://www.cs.uaf.edu/courses/cs441/notes/sse-avx/</a></p></li>    <li><p><a  href=\"http://www.euclideanspace.com\">http://www.euclideanspace.com</a></p></li>    <li><p><a  href=\"https://www.3dgep.com/category/math/\">https://www.3dgep.com/category/math/</a></p></li>  </ul>    <p><br>    <p>Quelques liens en français (in french) :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"http://villemin.gerard.free.fr/Wwwgvmm/Nombre.htm\">http://villemin.gerard.free.fr/Wwwgvmm/Nombre.htm</a></p></li>    <li><p><a  href=\"https://ljk.imag.fr/membres/Bernard.Ycart/mel/\">https://ljk.imag.fr/membres/Bernard.Ycart/mel/</a></p></li>    <li><p><a  href=\"https://www.gladir.com/CODER/ASM8086/\">https://www.gladir.com/CODER/ASM8086/</a></p></li>  </ul>    <p><br>    <p>Others interesting articles, papers at some points:<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://conkerjo.wordpress.com/2009/06/13/spatial-hashing-implementation-for-fast-2d-collisions/\">https://conkerjo.wordpress.com/2009/06/13/spatial-hashing-implementation-for-fast-2d-collisions/</a></p></li>    <li><p><a  href=\"https://realhet.wordpress.com/2016/11/02/fast-sse-3x3-median-filter-for-rgb24-images/\">https://realhet.wordpress.com/2016/11/02/fast-sse-3x3-median-filter-for-rgb24-images/</a></p></li>    <li><p><a  href=\"http://www.jagregory.com/abrash-black-book/\">http://www.jagregory.com/abrash-black-book/</a></p></li>    <li><p><a  href=\"http://x86asm.net/articles/fixed-point-arithmetic-and-tricks/\">http://x86asm.net/articles/fixed-point-arithmetic-and-tricks/</a></p></li>    <li><p><a  href=\"http://lolengine.net/blog/2011/3/20/understanding-fast-float-integer-conversions\">http://lolengine.net/blog/2011/3/20/understanding-fast-float-integer-conversions</a></p></li>    <li><p><a  href=\"http://chrishecker.com/Miscellaneous_Technical_Articles\">http://chrishecker.com/Miscellaneous_Technical_Articles</a></p></li>    <li><p><a  href=\"http://catlikecoding.com/unity/tutorials/rendering/part-1/\">http://catlikecoding.com/unity/tutorials/rendering/part-1/</a></p></li>  </ul>    <p><br>    <p>You can also found some papers in <b>DocRefs</b> folder<br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>    <p><b>Credits :</b><br> </p>    <ul class=\"paragraph_spacing\">    <li><p>FPC/Lazarus</p></li>    <li><p>GLScene</p></li>    <li><p>All authors of papers and web links</p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> LICENCE : MPL <br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> *============================================================================== J.Delauney (BeanzMaster)  Peter Dyson (Dicepd)  ", "tags": "", "loc": "GLZVectorMath.html"},
     {"title": "GLZVectorMath.TGLZVector2i", "text": "<code>TGLZVector2i</code> : 2D Integer vector ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html"},
     {"title": "GLZVectorMath.TGLZVector2i.V", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#V"},
     {"title": "GLZVectorMath.TGLZVector2i.X", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#X"},
     {"title": "GLZVectorMath.TGLZVector2i.Y", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Y"},
     {"title": "GLZVectorMath.TGLZVector2i.Width", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Width"},
     {"title": "GLZVectorMath.TGLZVector2i.Height", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Height"},
     {"title": "GLZVectorMath.TGLZVector2i.Create", "text": "<code>Create</code> : Initialize <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#X\">X</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Y\">Y</a> value    aX : Integer &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#X\">X</a> aY : Integer &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Y\">Y</a>  aX : Integer &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#X\">X</a> aY : Integer &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Y\">Y</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Create"},
     {"title": "GLZVectorMath.TGLZVector2i.ToString", "text": "<code>ToString</code>    Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Y\">y</a>&quot;)&quot;  ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector2i.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#+"},
     {"title": "GLZVectorMath.TGLZVector2i.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#-"},
     {"title": "GLZVectorMath.TGLZVector2i.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#*"},
     {"title": "GLZVectorMath.TGLZVector2i.Div", "text": "<code>Div</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Div"},
     {"title": "GLZVectorMath.TGLZVector2i.Div", "text": "<code>Div</code> : Divide one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> by one Integer     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Div"},
     {"title": "GLZVectorMath.TGLZVector2i.+", "text": "<code>+</code> : Add one Integer to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#+"},
     {"title": "GLZVectorMath.TGLZVector2i.+", "text": "<code>+</code> : Add one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#+"},
     {"title": "GLZVectorMath.TGLZVector2i.-", "text": "<code>-</code> : Sub one Integer to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#-"},
     {"title": "GLZVectorMath.TGLZVector2i.-", "text": "<code>-</code> : Sub one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#-"},
     {"title": "GLZVectorMath.TGLZVector2i.*", "text": "<code>*</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> by one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#*"},
     {"title": "GLZVectorMath.TGLZVector2i./", "text": "<code>/</code> : Divide one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> by one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#/"},
     {"title": "GLZVectorMath.TGLZVector2i.-", "text": "<code>-</code> : Negate a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#-"},
     {"title": "GLZVectorMath.TGLZVector2i.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#="},
     {"title": "GLZVectorMath.TGLZVector2i.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#<"},
     {"title": "GLZVectorMath.TGLZVector2i.mod", "text": "<code>mod</code> : <code>Mod</code> of two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> &ndash; Remainder of Division A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#mod"},
     {"title": "GLZVectorMath.TGLZVector2i.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2i.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> between self and an Integer    B : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2i.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2i.Max", "text": "<code>Max</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> between self and an Integer    B : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2i.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Clamp\">Clamp</a> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2i.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> each component of Self beatween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Max\">max</a> float     AMin : Integer AMax : Integer <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> AMin : Integer AMax : Integer", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2i.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> and add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector2i.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Div\">div</a> with an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector2i.Length", "text": "<code>Length</code> : Return self <code>length</code>    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Length"},
     {"title": "GLZVectorMath.TGLZVector2i.LengthSquare", "text": "<code>LengthSquare</code> : Return self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Length\">length</a> squared    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#LengthSquare"},
     {"title": "GLZVectorMath.TGLZVector2i.Distance", "text": "<code>Distance</code> : Return <code>distance</code> from self to an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Distance"},
     {"title": "GLZVectorMath.TGLZVector2i.DistanceSquare", "text": "<code>DistanceSquare</code> : Return Self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html#Distance\">distance</a> squared    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#DistanceSquare"},
     {"title": "GLZVectorMath.TGLZVector2i.DotProduct", "text": "<code>DotProduct</code> : Return the dot product of self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#DotProduct"},
     {"title": "GLZVectorMath.TGLZVector2i.AngleBetween", "text": "<code>AngleBetween</code> : Return angle between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>, relative to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> as a Center Point     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#AngleBetween"},
     {"title": "GLZVectorMath.TGLZVector2i.AngleCosine", "text": "<code>AngleCosine</code> : Return the angle cosine between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#AngleCosine"},
     {"title": "GLZVectorMath.TGLZVector2i.Abs", "text": "<code>Abs</code> : Return absolute value of self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2i.html#Abs"},
     {"title": "GLZVectorMath.TGLZVector2f", "text": "<code>TGLZVector2f</code> : 2D Float vector (Single) ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#V"},
     {"title": "GLZVectorMath.TGLZVector2f.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#X"},
     {"title": "GLZVectorMath.TGLZVector2f.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Y"},
     {"title": "GLZVectorMath.TGLZVector2f.Width", "text": "Surface size ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Width"},
     {"title": "GLZVectorMath.TGLZVector2f.Height", "text": "Surface size ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Height"},
     {"title": "GLZVectorMath.TGLZVector2f.Create", "text": "<code>Create</code> : Initialize <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#X\">X</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Y\">Y</a> float values    aX : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#X\">X</a> aY : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Y\">Y</a>  aX : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#X\">X</a> aY : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Y\">Y</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Create"},
     {"title": "GLZVectorMath.TGLZVector2f.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Y\">y</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector2f.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#+"},
     {"title": "GLZVectorMath.TGLZVector2f.+", "text": "<code>+</code> : Add one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#+"},
     {"title": "GLZVectorMath.TGLZVector2f.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#-"},
     {"title": "GLZVectorMath.TGLZVector2f.-", "text": "<code>-</code> : Substract one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#-"},
     {"title": "GLZVectorMath.TGLZVector2f.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#*"},
     {"title": "GLZVectorMath.TGLZVector2f.*", "text": "<code>*</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#*"},
     {"title": "GLZVectorMath.TGLZVector2f./", "text": "<code>/</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#/"},
     {"title": "GLZVectorMath.TGLZVector2f.+", "text": "<code>+</code> : Add one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#+"},
     {"title": "GLZVectorMath.TGLZVector2f.-", "text": "<code>-</code> : Substract one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#-"},
     {"title": "GLZVectorMath.TGLZVector2f.*", "text": "<code>*</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> by a Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#*"},
     {"title": "GLZVectorMath.TGLZVector2f./", "text": "<code>/</code> : Divide one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> by a Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#/"},
     {"title": "GLZVectorMath.TGLZVector2f./", "text": "<code>/</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#/"},
     {"title": "GLZVectorMath.TGLZVector2f.-", "text": "<code>-</code> : Negate a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#-"},
     {"title": "GLZVectorMath.TGLZVector2f.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#="},
     {"title": "GLZVectorMath.TGLZVector2f.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#<"},
     {"title": "GLZVectorMath.TGLZVector2f.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2f.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> between self and a Float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2f.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2f.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> between self and a Float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2f.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Clamp\">Clamp</a> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2f.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Max\">max</a> Float     AMin : Single AMax : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> AMin : Single AMax : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2f.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> and add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector2f.MulSub", "text": "<code>MulSub</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> and substract an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#MulSub"},
     {"title": "GLZVectorMath.TGLZVector2f.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> and div with an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector2f.Length", "text": "<code>Length</code> : Return self <code>length</code>    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Length"},
     {"title": "GLZVectorMath.TGLZVector2f.LengthSquare", "text": "<code>LengthSquare</code> : Return self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Length\">length</a> squared    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#LengthSquare"},
     {"title": "GLZVectorMath.TGLZVector2f.Distance", "text": "<code>Distance</code> : Return <code>distance</code> from self to an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Distance"},
     {"title": "GLZVectorMath.TGLZVector2f.DistanceSquare", "text": "<code>DistanceSquare</code> : Return Self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html#Distance\">distance</a> squared     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> :  Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#DistanceSquare"},
     {"title": "GLZVectorMath.TGLZVector2f.Normalize", "text": "<code>Normalize</code> : Return self normalized <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Normalize"},
     {"title": "GLZVectorMath.TGLZVector2f.DotProduct", "text": "<code>DotProduct</code> : Return the dot product of self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#DotProduct"},
     {"title": "GLZVectorMath.TGLZVector2f.AngleBetween", "text": "<code>AngleBetween</code> : Return angle between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>, relative to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> as a Center Point     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#AngleBetween"},
     {"title": "GLZVectorMath.TGLZVector2f.AngleCosine", "text": "<code>AngleCosine</code> : Return the angle cosine between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#AngleCosine"},
     {"title": "GLZVectorMath.TGLZVector2f.Abs", "text": "<code>Abs</code> : Return absolute value of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Abs"},
     {"title": "GLZVectorMath.TGLZVector2f.Round", "text": "<code>Round</code> : <code>Round</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Round"},
     {"title": "GLZVectorMath.TGLZVector2f.Trunc", "text": "<code>Trunc</code> : <code>Trunc</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Trunc"},
     {"title": "GLZVectorMath.TGLZVector2f.Floor", "text": "<code>Floor</code> : <code>Floor</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Floor"},
     {"title": "GLZVectorMath.TGLZVector2f.Ceil", "text": "<code>Ceil</code> : <code>Ceil</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Ceil"},
     {"title": "GLZVectorMath.TGLZVector2f.Fract", "text": "<code>Fract</code> : Return factorial of Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Fract"},
     {"title": "GLZVectorMath.TGLZVector2f.Modf", "text": "<code>Modf</code> : Return remainder of each component    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Modf"},
     {"title": "GLZVectorMath.TGLZVector2f.fMod", "text": "<code>fMod</code> : Return remainder of each component as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> :  <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> : ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#fMod"},
     {"title": "GLZVectorMath.TGLZVector2f.Sqrt", "text": "<code>Sqrt</code> : Return square root of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#Sqrt"},
     {"title": "GLZVectorMath.TGLZVector2f.InvSqrt", "text": "<code>InvSqrt</code> : Return inversed square root of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2f.html#InvSqrt"},
     {"title": "GLZVectorMath.TGLZVector2d", "text": "<code>TGLZVector2d</code> : 2D Float vector (Double) ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#V"},
     {"title": "GLZVectorMath.TGLZVector2d.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#X"},
     {"title": "GLZVectorMath.TGLZVector2d.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Y"},
     {"title": "GLZVectorMath.TGLZVector2d.Width", "text": "Surface size ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Width"},
     {"title": "GLZVectorMath.TGLZVector2d.Height", "text": "Surface size ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Height"},
     {"title": "GLZVectorMath.TGLZVector2d.Create", "text": "<code>Create</code> : Initialize <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#X\">X</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Y\">Y</a> float values    aX : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#X\">X</a> aY : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Y\">Y</a>  aX : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#X\">X</a> aY : Single &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Y\">Y</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Create"},
     {"title": "GLZVectorMath.TGLZVector2d.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Y\">y</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector2d.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#+"},
     {"title": "GLZVectorMath.TGLZVector2d.+", "text": "<code>+</code> : Add one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#+"},
     {"title": "GLZVectorMath.TGLZVector2d.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#-"},
     {"title": "GLZVectorMath.TGLZVector2d.-", "text": "<code>-</code> : Substract one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#-"},
     {"title": "GLZVectorMath.TGLZVector2d.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#*"},
     {"title": "GLZVectorMath.TGLZVector2d.*", "text": "<code>*</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#*"},
     {"title": "GLZVectorMath.TGLZVector2d./", "text": "<code>/</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#/"},
     {"title": "GLZVectorMath.TGLZVector2d.+", "text": "<code>+</code> : Add one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#+"},
     {"title": "GLZVectorMath.TGLZVector2d.-", "text": "<code>-</code> : Substract one Float to one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#-"},
     {"title": "GLZVectorMath.TGLZVector2d.*", "text": "<code>*</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> by a Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#*"},
     {"title": "GLZVectorMath.TGLZVector2d./", "text": "<code>/</code> : Divide one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> by a Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#/"},
     {"title": "GLZVectorMath.TGLZVector2d./", "text": "<code>/</code> : Multiply one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#/"},
     {"title": "GLZVectorMath.TGLZVector2d.-", "text": "<code>-</code> : Negate a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#-"},
     {"title": "GLZVectorMath.TGLZVector2d.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#="},
     {"title": "GLZVectorMath.TGLZVector2d.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#<"},
     {"title": "GLZVectorMath.TGLZVector2d.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2d.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> between self and a Float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Min"},
     {"title": "GLZVectorMath.TGLZVector2d.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2d.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> between self and a Float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Max"},
     {"title": "GLZVectorMath.TGLZVector2d.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Clamp\">Clamp</a> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2d.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Max\">max</a> Float     AMin : Single AMax : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> AMin : Single AMax : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector2d.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> and add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector2d.MulSub", "text": "<code>MulSub</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> and substract an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#MulSub"},
     {"title": "GLZVectorMath.TGLZVector2d.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> and div with an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector2d.Length", "text": "<code>Length</code> : Return self <code>length</code>    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Length"},
     {"title": "GLZVectorMath.TGLZVector2d.LengthSquare", "text": "<code>LengthSquare</code> : Return self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Length\">length</a> squared    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#LengthSquare"},
     {"title": "GLZVectorMath.TGLZVector2d.Distance", "text": "<code>Distance</code> : Return <code>distance</code> from self to an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Distance"},
     {"title": "GLZVectorMath.TGLZVector2d.DistanceSquare", "text": "<code>DistanceSquare</code> : Return Self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html#Distance\">distance</a> squared     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> :  Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#DistanceSquare"},
     {"title": "GLZVectorMath.TGLZVector2d.Normalize", "text": "<code>Normalize</code> : Return self normalized <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Normalize"},
     {"title": "GLZVectorMath.TGLZVector2d.DotProduct", "text": "<code>DotProduct</code> : Return the dot product of self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#DotProduct"},
     {"title": "GLZVectorMath.TGLZVector2d.AngleBetween", "text": "<code>AngleBetween</code> : Return angle between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>, relative to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> as a Center Point     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#AngleBetween"},
     {"title": "GLZVectorMath.TGLZVector2d.AngleCosine", "text": "<code>AngleCosine</code> : Return the angle cosine between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#AngleCosine"},
     {"title": "GLZVectorMath.TGLZVector2d.Abs", "text": "<code>Abs</code> : Return absolute value of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Abs"},
     {"title": "GLZVectorMath.TGLZVector2d.Round", "text": "<code>Round</code> : <code>Round</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Round"},
     {"title": "GLZVectorMath.TGLZVector2d.Trunc", "text": "<code>Trunc</code> : <code>Trunc</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Trunc"},
     {"title": "GLZVectorMath.TGLZVector2d.Floor", "text": "<code>Floor</code> : <code>Floor</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Floor"},
     {"title": "GLZVectorMath.TGLZVector2d.Ceil", "text": "<code>Ceil</code> : <code>Ceil</code> Self to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Ceil"},
     {"title": "GLZVectorMath.TGLZVector2d.Fract", "text": "<code>Fract</code> : Return factorial of Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Fract"},
     {"title": "GLZVectorMath.TGLZVector2d.Modf", "text": "<code>Modf</code> : Return remainder of each component    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Modf"},
     {"title": "GLZVectorMath.TGLZVector2d.fMod", "text": "<code>fMod</code> : Return remainder of each component as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> :  <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> : ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#fMod"},
     {"title": "GLZVectorMath.TGLZVector2d.Sqrt", "text": "<code>Sqrt</code> : Return square root of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#Sqrt"},
     {"title": "GLZVectorMath.TGLZVector2d.InvSqrt", "text": "<code>InvSqrt</code> : Return inversed square root of each component    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2d.html\">TGLZVector2d</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2d.html#InvSqrt"},
     {"title": "GLZVectorMath.TGLZVector3b", "text": "<code>TGLZVector3b</code> : 3D Byte vector ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#V"},
     {"title": "GLZVectorMath.TGLZVector3b.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#X"},
     {"title": "GLZVectorMath.TGLZVector3b.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Y"},
     {"title": "GLZVectorMath.TGLZVector3b.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Z"},
     {"title": "GLZVectorMath.TGLZVector3b.Red", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Red"},
     {"title": "GLZVectorMath.TGLZVector3b.Green", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Green"},
     {"title": "GLZVectorMath.TGLZVector3b.Blue", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector3b.Create", "text": "<code>Create</code> : Initialize <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#X\">X</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Y\">Y</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#And\">and</a> values in range of 0..255      aX : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#X\">X</a> aY : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Y\">Y</a> aZ : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Z\">Z</a> TGLZ  aX : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#X\">X</a> aY : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Y\">Y</a> aZ : Byte &ndash; value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Z\">Z</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Create"},
     {"title": "GLZVectorMath.TGLZVector3b.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Z\">z</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector3b.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#+"},
     {"title": "GLZVectorMath.TGLZVector3b.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#-"},
     {"title": "GLZVectorMath.TGLZVector3b.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#*"},
     {"title": "GLZVectorMath.TGLZVector3b.Div", "text": "<code>Div</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Div"},
     {"title": "GLZVectorMath.TGLZVector3b.+", "text": "<code>+</code> : Add to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> a Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#+"},
     {"title": "GLZVectorMath.TGLZVector3b.-", "text": "<code>-</code> : Substract to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> a Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#-"},
     {"title": "GLZVectorMath.TGLZVector3b.*", "text": "<code>*</code> : Multiply each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> by a Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#*"},
     {"title": "GLZVectorMath.TGLZVector3b.*", "text": "<code>*</code> :Multiply each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> by a Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#*"},
     {"title": "GLZVectorMath.TGLZVector3b.Div", "text": "<code>Div</code> : Divide each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> by a Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Div"},
     {"title": "GLZVectorMath.TGLZVector3b.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#="},
     {"title": "GLZVectorMath.TGLZVector3b.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> are NOT equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#<"},
     {"title": "GLZVectorMath.TGLZVector3b.And", "text": "<code>And</code> : Logical Operator &quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#And\">AND</a>&quot; between two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#And"},
     {"title": "GLZVectorMath.TGLZVector3b.Or", "text": "<code>Or</code> : Logical Operator &quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#or\">OR</a>&quot; between two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Or"},
     {"title": "GLZVectorMath.TGLZVector3b.Xor", "text": "<code>Xor</code> : Logical Operator &quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#Xor\">XOR</a>&quot; between two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Xor"},
     {"title": "GLZVectorMath.TGLZVector3b.And", "text": "<code>And</code> : Logical Operator &quot;<code>AND</code>&quot; between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <code>and</code> a Byte     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#And"},
     {"title": "GLZVectorMath.TGLZVector3b.or", "text": "<code>or</code> : Logical Operator &quot;<code>OR</code>&quot; between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#And\">and</a> a Byte    : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#or"},
     {"title": "GLZVectorMath.TGLZVector3b.Xor", "text": "<code>Xor</code> : Logical Operator &quot;<code>XOR</code>&quot; between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html#And\">and</a> a Byte     : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Xor"},
     {"title": "GLZVectorMath.TGLZVector3b.Swizzle", "text": "<code>Swizzle</code> : Return <code>swizzle</code> (shuffle) components of self    ASwizzle : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector3SwizzleRef\">TGLZVector3SwizzleRef</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> ASwizzle : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector3SwizzleRef\">TGLZVector3SwizzleRef</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector3b.html#Swizzle"},
     {"title": "GLZVectorMath.TGLZVector3i", "text": "<code>TGLZVector3i</code> : 3D Integer vector (only access definition, not extended, just for convenience) ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#V"},
     {"title": "GLZVectorMath.TGLZVector3i.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#X"},
     {"title": "GLZVectorMath.TGLZVector3i.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#Y"},
     {"title": "GLZVectorMath.TGLZVector3i.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#Z"},
     {"title": "GLZVectorMath.TGLZVector3i.Red", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#Red"},
     {"title": "GLZVectorMath.TGLZVector3i.Green", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#Green"},
     {"title": "GLZVectorMath.TGLZVector3i.Blue", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3i.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector3f", "text": "<code>TGLZVector3f</code> : 3D Float vector (only access definition, not extended, just for convenience) ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#V"},
     {"title": "GLZVectorMath.TGLZVector3f.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#X"},
     {"title": "GLZVectorMath.TGLZVector3f.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#Y"},
     {"title": "GLZVectorMath.TGLZVector3f.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#Z"},
     {"title": "GLZVectorMath.TGLZVector3f.Red", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#Red"},
     {"title": "GLZVectorMath.TGLZVector3f.Green", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#Green"},
     {"title": "GLZVectorMath.TGLZVector3f.Blue", "text": "As Color Components in RGB order ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector3f.ToString", "text": "    ", "tags": "", "loc": "GLZVectorMath.TGLZVector3f.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector4b", "text": "<code>TGLZVector4b</code> : 4D Byte vector ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#V"},
     {"title": "GLZVectorMath.TGLZVector4b.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#X"},
     {"title": "GLZVectorMath.TGLZVector4b.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Y"},
     {"title": "GLZVectorMath.TGLZVector4b.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Z"},
     {"title": "GLZVectorMath.TGLZVector4b.W", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#W"},
     {"title": "GLZVectorMath.TGLZVector4b.Red", "text": "As Color component ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Red"},
     {"title": "GLZVectorMath.TGLZVector4b.Green", "text": "As Color component ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Green"},
     {"title": "GLZVectorMath.TGLZVector4b.Blue", "text": "As Color component ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector4b.Alpha", "text": "As Color component ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Alpha"},
     {"title": "GLZVectorMath.TGLZVector4b.AsVector3b", "text": "As <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#AsVector3b"},
     {"title": "GLZVectorMath.TGLZVector4b.AsInteger", "text": "As 32 bit Integer ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#AsInteger"},
     {"title": "GLZVectorMath.TGLZVector4b.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Create\">Create</a> from <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#X\">x</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Y\">y</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Z\">z</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#W\">w</a> values. Default value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#W\">W</a> = 255      aX : Byte aY : Byte aZ : Byte aW : Byte  aX : Byte aY : Byte aZ : Byte aW : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4b.Create", "text": "<code>Create</code> : <code>Create</code> from a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#W\">w</a> value. Default value for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#W\">W</a> = 255    aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> aW : Byte  aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> aW : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4b.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#W\">w</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector4b.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> TGLZ  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#+"},
     {"title": "GLZVectorMath.TGLZVector4b.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#-"},
     {"title": "GLZVectorMath.TGLZVector4b.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#*"},
     {"title": "GLZVectorMath.TGLZVector4b.Div", "text": "<code>Div</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Div"},
     {"title": "GLZVectorMath.TGLZVector4b.+", "text": "<code>+</code> : Add one Byte to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#+"},
     {"title": "GLZVectorMath.TGLZVector4b.-", "text": "<code>-</code> : Sub one Byte to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#-"},
     {"title": "GLZVectorMath.TGLZVector4b.*", "text": "<code>*</code> : Multiply each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> by one Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#*"},
     {"title": "GLZVectorMath.TGLZVector4b.*", "text": "<code>*</code> : Multiply each componentof a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> by one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Single Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#*"},
     {"title": "GLZVectorMath.TGLZVector4b.Div", "text": "<code>Div</code> : Divide each component of a TGLZVector4bby one Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Div"},
     {"title": "GLZVectorMath.TGLZVector4b.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> TGLZ  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#="},
     {"title": "GLZVectorMath.TGLZVector4b.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#<"},
     {"title": "GLZVectorMath.TGLZVector4b.And", "text": "<code>And</code> : Operator <b><a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">AND</a></b> two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#And"},
     {"title": "GLZVectorMath.TGLZVector4b.Or", "text": "<code>Or</code> : Operator <b><a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#or\">OR</a></b> two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Or"},
     {"title": "GLZVectorMath.TGLZVector4b.Xor", "text": "<code>Xor</code> : Operator <b><a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Xor\">XOR</a></b> two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Xor"},
     {"title": "GLZVectorMath.TGLZVector4b.And", "text": "<code>And</code> : Operator <b><code>AND</code></b> one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <code>and</code> one Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#And"},
     {"title": "GLZVectorMath.TGLZVector4b.or", "text": "<code>or</code> : Operator <b><code>OR</code></b> one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> one Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#or"},
     {"title": "GLZVectorMath.TGLZVector4b.Xor", "text": "<code>Xor</code> : Operator <b><code>XOR</code></b> one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> one Byte     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Xor"},
     {"title": "GLZVectorMath.TGLZVector4b.DivideBy2", "text": "<code>DivideBy2</code> : Fast self divide by 2    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#DivideBy2"},
     {"title": "GLZVectorMath.TGLZVector4b.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> between self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4b.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> between self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> a float    B: Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B: Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4b.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> between self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4b.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> between self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> a float    B : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4b.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Clamp\">Clamp</a> Self between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Min\">min</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4b.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> each component of Self between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Min\">min</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Max\">max</a> float     AMin : Byte AMax : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> AMin : Byte AMax : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4b.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector4b.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#And\">and</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Div\">div</a> by an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector4b.Shuffle", "text": "<code>Shuffle</code> : Return <code>shuffle</code> components of self following params orders       X : Byte Y : Byte Z : Byte W : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> X : Byte Y : Byte Z : Byte W : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Shuffle"},
     {"title": "GLZVectorMath.TGLZVector4b.Swizzle", "text": "<code>Swizzle</code> : Return <code>swizzle</code> (<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html#Shuffle\">shuffle</a>) components of self from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> mask    ASwizzle: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> ASwizzle: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Swizzle"},
     {"title": "GLZVectorMath.TGLZVector4b.Combine", "text": "<code>Combine</code> : Return <code>Combine</code> = Self + (V2 * F1)     V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Combine"},
     {"title": "GLZVectorMath.TGLZVector4b.Combine2", "text": "<code>Combine2</code> : <code>Combine2</code> = (Self * F1) + (V2 * F2)      V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single F2 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single F2 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Combine2"},
     {"title": "GLZVectorMath.TGLZVector4b.Combine3", "text": "<code>Combine3</code> : Return <code>Combine3</code> = (Self * F1) + (V2 * F2) + (V3 * F3)        V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single F2 : Single F3 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> F1 : Single F2 : Single F3 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#Combine3"},
     {"title": "GLZVectorMath.TGLZVector4b.MinXYZComponent", "text": "<code>MinXYZComponent</code> : Return the minimum component value in XYZ    Byte ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#MinXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4b.MaxXYZComponent", "text": "<code>MaxXYZComponent</code> : Return the maximum component value in XYZ    Byte ", "tags": "", "loc": "GLZVectorMath.TGLZVector4b.html#MaxXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4i", "text": "<code>TGLZVector4i</code> : 4D Integer vector ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#V"},
     {"title": "GLZVectorMath.TGLZVector4i.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#X"},
     {"title": "GLZVectorMath.TGLZVector4i.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Y"},
     {"title": "GLZVectorMath.TGLZVector4i.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Z"},
     {"title": "GLZVectorMath.TGLZVector4i.W", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#W"},
     {"title": "GLZVectorMath.TGLZVector4i.Red", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Red"},
     {"title": "GLZVectorMath.TGLZVector4i.Green", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Green"},
     {"title": "GLZVectorMath.TGLZVector4i.Blue", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector4i.Alpha", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Alpha"},
     {"title": "GLZVectorMath.AsVector3i", "text": "As <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#AsVector3i"},
     {"title": "GLZVectorMath.TGLZVector4i.ST", "text": "As Texture coordinates <code>ST</code>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#UV\">UV</a> or <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#UV\">UV</a>,<code>ST</code> ????? ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#ST"},
     {"title": "GLZVectorMath.TGLZVector4i.UV", "text": "As Texture coordinates <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#ST\">ST</a>,<code>UV</code> or <code>UV</code>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#ST\">ST</a> ????? ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#UV"},
     {"title": "GLZVectorMath.TGLZVector4i.Left", "text": "As Legacy rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Left"},
     {"title": "GLZVectorMath.TGLZVector4i.Top", "text": "As Legacy rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Top"},
     {"title": "GLZVectorMath.TGLZVector4i.Right", "text": "As Legacy rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Right"},
     {"title": "GLZVectorMath.TGLZVector4i.Bottom", "text": "As Legacy rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Bottom"},
     {"title": "GLZVectorMath.TGLZVector4i.TopLeft", "text": "As bounding rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#TopLeft"},
     {"title": "GLZVectorMath.TGLZVector4i.BottomRight", "text": "As bounding rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#BottomRight"},
     {"title": "GLZVectorMath.TGLZVector4i.Create", "text": "<code>Create</code> : Self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Create\">Create</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> from <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#X\">x</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Y\">y</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Z\">z</a>,<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">w</a> value      aX : Longint aY : Longint aZ : Longint aW : Longint  aX : Longint aY : Longint aZ : Longint aW : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4i.Create", "text": "<code>Create</code> : Self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Create\">Create</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> from a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">w</a> value as homogenous. Default <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">W</a>=0    aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a> aW : Longint  aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3i.html\">TGLZVector3i</a> aW : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4i.Create", "text": "<code>Create</code> : Self <code>Create</code> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> from a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">w</a> value as homogenous. Default <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">W</a>=0    aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> aW : Longint  aValue : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3b.html\">TGLZVector3b</a> aW : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4i.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#W\">w</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector4i.+", "text": "<code>+</code> :     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#+"},
     {"title": "GLZVectorMath.TGLZVector4i.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#-"},
     {"title": "GLZVectorMath.TGLZVector4i.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#*"},
     {"title": "GLZVectorMath.TGLZVector4i.Div", "text": "<code>Div</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Div"},
     {"title": "GLZVectorMath.TGLZVector4i.+", "text": "<code>+</code> : Add to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> one LongInt     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#+"},
     {"title": "GLZVectorMath.TGLZVector4i.-", "text": "<code>-</code> : Sub each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> one LongInt     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#-"},
     {"title": "GLZVectorMath.TGLZVector4i.*", "text": "<code>*</code> : Multiply one Int to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#*"},
     {"title": "GLZVectorMath.TGLZVector4i.*", "text": "<code>*</code> : Multiply each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> by one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#*"},
     {"title": "GLZVectorMath.TGLZVector4i.Div", "text": "<code>Div</code> : Divide each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> by one LongInt     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Div"},
     {"title": "GLZVectorMath.TGLZVector4i.-", "text": "<code>-</code> : Negate each components in Self    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#-"},
     {"title": "GLZVectorMath.TGLZVector4i.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#="},
     {"title": "GLZVectorMath.TGLZVector4i.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#<"},
     {"title": "GLZVectorMath.TGLZVector4i.DivideBy2", "text": "<code>DivideBy2</code> : Fast self divide by 2    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#DivideBy2"},
     {"title": "GLZVectorMath.TGLZVector4i.Abs", "text": "<code>Abs</code> : Return absolute value of each components in self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Abs"},
     {"title": "GLZVectorMath.TGLZVector4i.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4i.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> between self and a Longint     :  B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> :  B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4i.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4i.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> between self and a Longint    B : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4i.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Clamp\">Clamp</a> Self between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4i.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> each component of Self between a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Max\">max</a> float     AMin : Longint AMax : Longint <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> AMin : Longint AMax : Longint", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4i.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> and Add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector4i.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4b.html\">TGLZVector4b</a> and Divide by an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector4i.Shuffle", "text": "<code>Shuffle</code> : Return <code>shuffle</code> components of self following params orders       X : Byte Y : Byte Z : Byte W : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> X : Byte Y : Byte Z : Byte W : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Shuffle"},
     {"title": "GLZVectorMath.TGLZVector4i.Swizzle", "text": "<code>Swizzle</code> : Return <code>swizzle</code> (<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html#Shuffle\">shuffle</a>) components of self from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> mask    ASwizzle : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ASwizzle : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Swizzle"},
     {"title": "GLZVectorMath.TGLZVector4i.Combine", "text": "<code>Combine</code> : Return <code>Combine</code> = Self + (V2 * F2)     V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Combine"},
     {"title": "GLZVectorMath.TGLZVector4i.Combine2", "text": "<code>Combine2</code> : Return <code>Combine2</code> = (Self * F1) + (V2 * F2)      V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single F2 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single F2 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Combine2"},
     {"title": "GLZVectorMath.TGLZVector4i.Combine3", "text": "<code>Combine3</code> : Return <code>Combine3</code> = (Self * F1) + (V2 * F2) + (V3 * F3)        V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single F2 : Single F3 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> F1 : Single F2 : Single F3 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#Combine3"},
     {"title": "GLZVectorMath.TGLZVector4i.MinXYZComponent", "text": "<code>MinXYZComponent</code> : Return the minimum component value in XYZ    TGLZ  ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#MinXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4i.MaxXYZComponent", "text": "<code>MaxXYZComponent</code> : Return the maximum component value in XYZ    TGLZ  ", "tags": "", "loc": "GLZVectorMath.TGLZVector4i.html#MaxXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4f", "text": "<code>TGLZVector4f</code> : 4D Float vector ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#V"},
     {"title": "GLZVectorMath.TGLZVector4f.X", "text": "Legacy access² ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#X"},
     {"title": "GLZVectorMath.TGLZVector4f.Y", "text": "Legacy access² ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Y"},
     {"title": "GLZVectorMath.TGLZVector4f.Z", "text": "Legacy access² ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Z"},
     {"title": "GLZVectorMath.TGLZVector4f.W", "text": "Legacy access² ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#W"},
     {"title": "GLZVectorMath.TGLZVector4f.Red", "text": "As Color components in RGBA order ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Red"},
     {"title": "GLZVectorMath.TGLZVector4f.Green", "text": "As Color components in RGBA order ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Green"},
     {"title": "GLZVectorMath.TGLZVector4f.Blue", "text": "As Color components in RGBA order ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Blue"},
     {"title": "GLZVectorMath.TGLZVector4f.Alpha", "text": "As Color components in RGBA order ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Alpha"},
     {"title": "GLZVectorMath.TGLZVector4f.AsVector3f", "text": "As <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#AsVector3f"},
     {"title": "GLZVectorMath.TGLZVector4f.UV", "text": "As Texture Coordinates ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#UV"},
     {"title": "GLZVectorMath.TGLZVector4f.ST", "text": "As Texture Coordinates ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#ST"},
     {"title": "GLZVectorMath.TGLZVector4f.Left", "text": "As Lagacy Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Left"},
     {"title": "GLZVectorMath.TGLZVector4f.Top", "text": "As Lagacy Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Top"},
     {"title": "GLZVectorMath.TGLZVector4f.Right", "text": "As Lagacy Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Right"},
     {"title": "GLZVectorMath.TGLZVector4f.Bottom", "text": "As Lagacy Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Bottom"},
     {"title": "GLZVectorMath.TGLZVector4f.TopLeft", "text": "As Bounding Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#TopLeft"},
     {"title": "GLZVectorMath.TGLZVector4f.BottomRight", "text": "As Bounding Rect ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#BottomRight"},
     {"title": "GLZVectorMath.TGLZVector4f.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Create\">Create</a> as Homogenous from a Float. <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">W</a> value set by default to 0.0   AValue : Single  AValue : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4f.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Create\">Create</a> as Homogenous from three Float. <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">W</a> value set by default to 0.0     aX : Single aY : Single aZ : Single  aX : Single aY : Single aZ : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4f.Create", "text": "<code>Create</code> : <code>Create</code> As Homogenous from a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">w</a> value set by default to 0.0    anAffineVector : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> aW : Single  anAffineVector : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> aW : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Create"},
     {"title": "GLZVectorMath.TGLZVector4f.CreatePoint", "text": "<code>CreatePoint</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Create\">Create</a> As Point from a Float. <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">W</a> value set by default to 1.0   AValue : Single  AValue : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#CreatePoint"},
     {"title": "GLZVectorMath.TGLZVector4f.CreatePoint", "text": "<code>CreatePoint</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Create\">Create</a> As Point from three Float. <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">W</a> value set by default to 1.0     aX : Single aY : Single aZ : Single  aX : Single aY : Single aZ : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#CreatePoint"},
     {"title": "GLZVectorMath.TGLZVector4f.CreatePoint", "text": "<code>CreatePoint</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Create\">Create</a> As Point from a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> and <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">w</a> value set by default to 1.0   anAffineVector : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a>  anAffineVector : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#CreatePoint"},
     {"title": "GLZVectorMath.TGLZVector4f.ToString", "text": "<code>ToString</code> : Return Vector to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#W\">w</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#ToString"},
     {"title": "GLZVectorMath.TGLZVector4f.+", "text": "<code>+</code> : Add two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#+"},
     {"title": "GLZVectorMath.TGLZVector4f.-", "text": "<code>-</code> : Sub two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#-"},
     {"title": "GLZVectorMath.TGLZVector4f.*", "text": "<code>*</code> : Multiply two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#*"},
     {"title": "GLZVectorMath.TGLZVector4f./", "text": "<code>/</code> : Divide two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#/"},
     {"title": "GLZVectorMath.TGLZVector4f.+", "text": "<code>+</code> : Add to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#+"},
     {"title": "GLZVectorMath.TGLZVector4f.-", "text": "<code>-</code> : Sub each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> by one float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#-"},
     {"title": "GLZVectorMath.TGLZVector4f.*", "text": "<code>*</code> : Multiply one Float to each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#*"},
     {"title": "GLZVectorMath.TGLZVector4f./", "text": "<code>/</code> : Divide each component of a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> by one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#/"},
     {"title": "GLZVectorMath.TGLZVector4f.-", "text": "<code>-</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Negate\">Negate</a> one <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#-"},
     {"title": "GLZVectorMath.TGLZVector4f.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#="},
     {"title": "GLZVectorMath.TGLZVector4f.>=", "text": "<code>&gt;=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are greater or equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if A greater or equal than B  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#>="},
     {"title": "GLZVectorMath.TGLZVector4f.<=", "text": "<code>&lt;=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are less or equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if A Less or equal than B  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#<="},
     {"title": "GLZVectorMath.TGLZVector4f.>", "text": "<code>&gt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are greater     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if A greater than B  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#>"},
     {"title": "GLZVectorMath.TGLZVector4f.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are less     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if A Less than B  A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#<"},
     {"title": "GLZVectorMath.TGLZVector4f.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#<"},
     {"title": "GLZVectorMath.TGLZVector4f.Shuffle", "text": "<code>Shuffle</code> : Return <code>shuffle</code> components of self following params orders       X : Byte Y : Byte Z : Byte W : Byte <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> X : Byte Y : Byte Z : Byte W : Byte", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Shuffle"},
     {"title": "GLZVectorMath.TGLZVector4f.Swizzle", "text": "<code>Swizzle</code> : Return <code>swizzle</code> (<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Shuffle\">shuffle</a>) components of self from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> mask    ASwizzle: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ASwizzle: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector4SwizzleRef\">TGLZVector4SwizzleRef</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Swizzle"},
     {"title": "GLZVectorMath.TGLZVector4f.MinXYZComponent", "text": "<code>MinXYZComponent</code> : Return the minimum component value in XYZ    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#MinXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4f.MaxXYZComponent", "text": "<code>MaxXYZComponent</code> : Return the maximum component value in XYZ    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#MaxXYZComponent"},
     {"title": "GLZVectorMath.TGLZVector4f.Abs", "text": "<code>Abs</code> : Return absolute value of self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Abs"},
     {"title": "GLZVectorMath.TGLZVector4f.Negate", "text": "<code>Negate</code> : <code>Negate</code> Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Negate"},
     {"title": "GLZVectorMath.TGLZVector4f.DivideBy2", "text": "<code>DivideBy2</code> : Fast Self Divide by 2    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#DivideBy2"},
     {"title": "GLZVectorMath.TGLZVector4f.Length", "text": "<code>Length</code> : Return self <code>length</code>    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Length"},
     {"title": "GLZVectorMath.TGLZVector4f.LengthSquare", "text": "<code>LengthSquare</code> : Return self <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Length\">length</a> squared    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#LengthSquare"},
     {"title": "GLZVectorMath.TGLZVector4f.Distance", "text": "<code>Distance</code> : Return <code>Distance</code> from self to an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Distance"},
     {"title": "GLZVectorMath.TGLZVector4f.DistanceSquare", "text": "<code>DistanceSquare</code> : Return <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Distance\">Distance</a> squared from self to an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#DistanceSquare"},
     {"title": "GLZVectorMath.TGLZVector4f.Spacing", "text": "<code>Spacing</code> : Calculates <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Abs\">Abs</a>(v1[<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#X\">x</a>]-v2[<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#X\">x</a>])+<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Abs\">Abs</a>(v1[<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Y\">y</a>]-v2[<a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Y\">y</a>])+..., also know as &quot;Norm1&quot;.    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Spacing"},
     {"title": "GLZVectorMath.TGLZVector4f.DotProduct", "text": "<code>DotProduct</code> : Return the Dot product of self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : Single A :", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#DotProduct"},
     {"title": "GLZVectorMath.TGLZVector4f.CrossProduct", "text": "<code>CrossProduct</code> : Return the Cross product of self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#CrossProduct"},
     {"title": "GLZVectorMath.TGLZVector4f.Normalize", "text": "<code>Normalize</code> : Return self normalized    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Normalize"},
     {"title": "GLZVectorMath.TGLZVector4f.Norm", "text": "<code>Norm</code> : Return normal    Single ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Norm"},
     {"title": "GLZVectorMath.TGLZVector4f.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4f.Min", "text": "<code>Min</code> : Return the minimum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> between self and a float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Min"},
     {"title": "GLZVectorMath.TGLZVector4f.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> between self and another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4f.Max", "text": "<code>Max</code> : Return the maximum of each component in <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> between self and a float    B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Max"},
     {"title": "GLZVectorMath.TGLZVector4f.Clamp", "text": "<code>Clamp</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Clamp\">Clamp</a> Self beetween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Max\">max</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> AMin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> AMax : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4f.Clamp", "text": "<code>Clamp</code> : <code>Clamp</code> each component of Self beatween a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Min\">min</a> and a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Max\">max</a> float     AMin : Single AMax : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> AMin : Single AMax : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Clamp"},
     {"title": "GLZVectorMath.TGLZVector4f.MulAdd", "text": "<code>MulAdd</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> and Add an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#MulAdd"},
     {"title": "GLZVectorMath.TGLZVector4f.MulSub", "text": "<code>MulSub</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> and Substract an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#MulSub"},
     {"title": "GLZVectorMath.TGLZVector4f.MulDiv", "text": "<code>MulDiv</code> : Multiply Self by a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> and Divide by an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> C : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#MulDiv"},
     {"title": "GLZVectorMath.TGLZVector4f.Lerp", "text": "<code>Lerp</code> : Return linear interpolate value at T between self and B     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> T : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> T : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Lerp"},
     {"title": "GLZVectorMath.TGLZVector4f.AngleCosine", "text": "<code>AngleCosine</code> : Return the angle cosine between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#AngleCosine"},
     {"title": "GLZVectorMath.TGLZVector4f.AngleBetween", "text": "<code>AngleBetween</code> : Return angle between Self and an another <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>, relative to a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> as a Center Point     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ACenterPoint : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#AngleBetween"},
     {"title": "GLZVectorMath.TGLZVector4f.Combine", "text": "<code>Combine</code> : Return <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html#Combine3\">Combine3</a> = Self + (V2 * F2)     V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Combine"},
     {"title": "GLZVectorMath.TGLZVector4f.Combine2", "text": "<code>Combine2</code> : Return <code>Combine2</code> = (Self * F1) + (V2 * F2)      V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single F2 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single F2 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Combine2"},
     {"title": "GLZVectorMath.TGLZVector4f.Combine3", "text": "<code>Combine3</code> : Return <code>Combine3</code> = (Self * F1) + (V2 * F2) + (V3 * F3)        V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single F2 : Single F3 : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> V3 : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> F1 : Single F2 : Single F3 : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Combine3"},
     {"title": "GLZVectorMath.TGLZVector4f.Round", "text": "<code>Round</code> : <code>Round</code> each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Round"},
     {"title": "GLZVectorMath.TGLZVector4f.Trunc", "text": "<code>Trunc</code> : <code>Trunc</code> each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Trunc"},
     {"title": "GLZVectorMath.TGLZVector4f.Floor", "text": "<code>Floor</code> : <code>Floor</code> each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Floor"},
     {"title": "GLZVectorMath.TGLZVector4f.Ceil", "text": "<code>Ceil</code> : <code>Ceil</code> each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Ceil"},
     {"title": "GLZVectorMath.TGLZVector4f.Fract", "text": "<code>Fract</code> : Return fractionnal part of each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Fract"},
     {"title": "GLZVectorMath.TGLZVector4f.Sqrt", "text": "<code>Sqrt</code> : Return Square root of each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#Sqrt"},
     {"title": "GLZVectorMath.TGLZVector4f.InvSqrt", "text": "<code>InvSqrt</code> : Return Inverse Square root of each components in Self    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector4f.html#InvSqrt"},
     {"title": "GLZVectorMath.TGLZHmgPlane", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html"},
     {"title": "GLZVectorMath.V", "text": "should have type compat with other vector4f ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#V"},
     {"title": "GLZVectorMath.TGLZHmgPlane.A", "text": "Plane Parameter access ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#A"},
     {"title": "GLZVectorMath.TGLZHmgPlane.B", "text": "Plane Parameter access ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#B"},
     {"title": "GLZVectorMath.TGLZHmgPlane.C", "text": "Plane Parameter access ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#C"},
     {"title": "GLZVectorMath.TGLZHmgPlane.D", "text": "Plane Parameter access ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#D"},
     {"title": "GLZVectorMath.TGLZHmgPlane.AsNormal3", "text": "super quick descriptive access to Normal as Affine Vector. ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#AsNormal3"},
     {"title": "GLZVectorMath.TGLZHmgPlane.AsVector", "text": "as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#AsVector"},
     {"title": "GLZVectorMath.TGLZHmgPlane.X", "text": "legacy access so existing code works ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#X"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Y", "text": "legacy access so existing code works ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Y"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Z", "text": "legacy access so existing code works ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Z"},
     {"title": "GLZVectorMath.TGLZHmgPlane.W", "text": "legacy access so existing code works ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#W"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Create", "text": "<code>Create</code> : Will allow non unit vectors but basically <b>DON'T DO IT</b>.<br> <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">A</a> non unit vector WILL calculate the wrong <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#Distance\">distance</a> to the plane.     point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> normal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> TGLZ  point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> normal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Create"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Create", "text": "<code>Create</code> : <code>Create</code> and Computes the parameters of plane defined by three points.     p1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> p2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> p3 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  p1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> p2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> p3 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Create"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Normalize", "text": "<code>Normalize</code> : <code>Normalize</code> self    ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Normalize"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Normalized", "text": "<code>Normalized</code> : Return self <code>normalized</code> plane    <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a> ", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Normalized"},
     {"title": "GLZVectorMath.TGLZHmgPlane.AbsDistance", "text": "<code>AbsDistance</code> : Return absolute <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#Distance\">distance</a> between self and <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">a</a> point    point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Single point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#AbsDistance"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Distance", "text": "<code>Distance</code> : Return signed <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#Distance\">distance</a> between self and <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">a</a> point    point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Single point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Distance"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Distance", "text": "<code>Distance</code> : Return <code>distance</code> between self and <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">a</a> sphere     Center : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius : Single Single Center : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius : Single", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Distance"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Perpendicular", "text": "<code>Perpendicular</code> : Calculates <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">a</a> vector <code>perpendicular</code> to P.<br> Self is assumed to be of unit length, subtract out any component parallel to Self    P : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> P : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Perpendicular"},
     {"title": "GLZVectorMath.TGLZHmgPlane.Reflect", "text": "<code>Reflect</code> : Reflects vector <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#V\">V</a> against Self (assumes self is <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#Normalized\">normalized</a>)    V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#Reflect"},
     {"title": "GLZVectorMath.TGLZHmgPlane.IsInHalfSpace", "text": "<code>IsInHalfSpace</code> : Return if <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html#A\">a</a> point is in half space    Point: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Boolean <code>True</code> if point is in Half Space Point: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZHmgPlane.html#IsInHalfSpace"},
     {"title": "GLZVectorMath.TGLZMatrix4f", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html"},
     {"title": "GLZVectorMath.M", "text": "2D Array Access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#M"},
     {"title": "GLZVectorMath.TGLZMatrix4f.V", "text": "Array of <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#V"},
     {"title": "GLZVectorMath.TGLZMatrix4f.VX", "text": "for AVX Access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#VX"},
     {"title": "GLZVectorMath.TGLZMatrix4f.X", "text": "Row access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#X"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Y", "text": "Row access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Y"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Z", "text": "Row access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Z"},
     {"title": "GLZVectorMath.TGLZMatrix4f.W", "text": "Row access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#W"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m11", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m11"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m12", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m12"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m13", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m13"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m14", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m14"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m21", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m21"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m22", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m22"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m23", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m23"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m24", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m24"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m31", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m31"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m32", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m32"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m33", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m33"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m34", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m34"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m41", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m41"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m42", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m42"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m43", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m43"},
     {"title": "GLZVectorMath.TGLZMatrix4f.m44", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#m44"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateIdentityMatrix", "text": "<code>CreateIdentityMatrix</code> : Create homogenous identity matrix    ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateIdentityMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateScaleMatrix", "text": "<code>CreateScaleMatrix</code> : Cretae Scale matrix from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>   V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>  V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateScaleMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateScaleMatrix", "text": "<code>CreateScaleMatrix</code> : Cretae Scale matrix from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>   V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateScaleMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateTranslationMatrix", "text": "<code>CreateTranslationMatrix</code> : Cretae Translation matrix from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>   V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>  V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateTranslationMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateTranslationMatrix", "text": "<code>CreateTranslationMatrix</code> : Cretae Translation matrix from <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>   V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateTranslationMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateScaleAndTranslationMatrix", "text": "<code>CreateScaleAndTranslationMatrix</code> : Creates a scale+translation matrix.<br> Scale is applied BEFORE applying offset    aScale : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Offset : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  aScale : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Offset : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateScaleAndTranslationMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixX", "text": "<code>CreateRotationMatrixX</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">X</a> from <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a> &amp; <a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a>    Sine : Single Cosine : Single  Sine : Single Cosine : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixX"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixX", "text": "<code>CreateRotationMatrixX</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">X</a> from Angle   Angle : Single &ndash; angle in rad  Angle : Single &ndash; angle in rad", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixX"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixY", "text": "<code>CreateRotationMatrixY</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">Y</a> from <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a> &amp; <a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a>    Sine : Single Cosine : Single  Sine : Single Cosine : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixY"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixY", "text": "<code>CreateRotationMatrixY</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">Y</a> from Angle   Angle : Single &ndash; angle in rad  Angle : Single &ndash; angle in rad", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixY"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixZ", "text": "<code>CreateRotationMatrixZ</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">Z</a> from <a class=\"normal\" href=\"GLZMath.html#Sin\">Sin</a> &amp; <a class=\"normal\" href=\"GLZMath.html#Cos\">Cos</a>    Sine : Single Cosine : Single  Sine : Single Cosine : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixZ"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrixZ", "text": "<code>CreateRotationMatrixZ</code> : Create Right Hand Rotation Matrix around <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">Z</a> from Angle   Angle : Single &ndash; angle in rad  Angle : Single &ndash; angle in rad", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrixZ"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrix", "text": "<code>CreateRotationMatrix</code> : Creates a rotation matrix along the given Axis by the given Angle in radians.    anAxis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> Angle : Single  anAxis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateRotationMatrix", "text": "<code>CreateRotationMatrix</code> : Creates a rotation matrix along the given Axis by the given Angle in radians.    anAxis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single  anAxis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateRotationMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateLookAtMatrix", "text": "<code>CreateLookAtMatrix</code> : Create Right Hand Look at matrix     Eye : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Center : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> NormUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  Eye : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Center : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> NormUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateLookAtMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateMatrixFromFrustum", "text": "<code>CreateMatrixFromFrustum</code> : Create View Matrix from Frustum parameters        Left : Single Right : Single Bottom : Single Top : Single ZNear : Single ZFar : Single  Left : Single Right : Single Bottom : Single Top : Single ZNear : Single ZFar : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateMatrixFromFrustum"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreatePerspectiveMatrix", "text": "<code>CreatePerspectiveMatrix</code> : Create Perspective View Matrix with FOV <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">X</a>      FOV : Single Aspect : Single ZNear : Single ZFar : Single  FOV : Single Aspect : Single ZNear : Single ZFar : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreatePerspectiveMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateOrthoMatrix", "text": "<code>CreateOrthoMatrix</code> : Create Orthogonal View Matrix from Frustum parameters        Left : Single Right : Single Bottom : Single Top : Single ZNear : Single ZFar : Single  Left : Single Right : Single Bottom : Single Top : Single ZNear : Single ZFar : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateOrthoMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreatePickMatrix", "text": "<code>CreatePickMatrix</code> : Create Pick Matrix       X : Single Y : Single DeltaX : Single DeltaY : Single Viewport : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>  X : Single Y : Single DeltaX : Single DeltaY : Single Viewport : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4i.html\">TGLZVector4i</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreatePickMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateParallelProjectionMatrix", "text": "<code>CreateParallelProjectionMatrix</code> : Creates a parallel projection matrix.<br> Transformed points will projected on the plane along the specified direction.    Plane : <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a> Dir : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  Plane : <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a> Dir : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateParallelProjectionMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateShadowMatrix", "text": "<code>CreateShadowMatrix</code> : Creates a shadow projection matrix.<br> Shadows will be projected onto the plane defined by planePoint and planeNormal, from lightPos.     PlanePoint : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> PlaneNormal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> LightPos : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  PlanePoint : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> PlaneNormal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> LightPos : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateShadowMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.CreateReflectionMatrix", "text": "<code>CreateReflectionMatrix</code> : Create a reflection matrix for the given plane.<br> Reflection matrix allow implementing planar reflectors in OpenGL (mirrors).    PlanePoint : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> PlaneNormal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  PlanePoint : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> PlaneNormal : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#CreateReflectionMatrix"},
     {"title": "GLZVectorMath.TGLZMatrix4f.ToString", "text": "<code>ToString</code> : Return Matrix to a formatted string :<br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#W\">w</a>&quot;)&quot; <br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#W\">w</a>&quot;)&quot; <br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#W\">w</a>&quot;)&quot; <br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#W\">w</a>&quot;)&quot; <br>    String ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#ToString"},
     {"title": "GLZVectorMath.TGLZMatrix4f.+", "text": "<code>+</code> : Add two matrices     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#+"},
     {"title": "GLZVectorMath.TGLZMatrix4f.+", "text": "<code>+</code> : Add to each component of the matrix one Float     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#+"},
     {"title": "GLZVectorMath.TGLZMatrix4f.-", "text": "<code>-</code> : Substract two matrices     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#-"},
     {"title": "GLZVectorMath.TGLZMatrix4f.-", "text": "<code>-</code> : Substract to each component of the matrix one Float  (B : Single   A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>   <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>  ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#-"},
     {"title": "GLZVectorMath.TGLZMatrix4f.*", "text": "<code>*</code> : Multiplies two matrices     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#*"},
     {"title": "GLZVectorMath.TGLZMatrix4f.*", "text": "<code>*</code> : Multiplies all elements of a 4x4 matrix with a factor     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#*"},
     {"title": "GLZVectorMath.TGLZMatrix4f.*", "text": "<code>*</code> : Transforms a homogeneous vector by multiplying it with a matrix     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#*"},
     {"title": "GLZVectorMath.TGLZMatrix4f.*", "text": "<code>*</code> : Transforms a homogeneous vector by multiplying it with a matrix     A : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> A : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#*"},
     {"title": "GLZVectorMath.TGLZMatrix4f./", "text": "<code>/</code> : Divide all elements of a 4x4 matrix by a divisor     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> B : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#/"},
     {"title": "GLZVectorMath.TGLZMatrix4f.-", "text": "<code>-</code> : Negate each element of a matrix    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#-"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Transpose", "text": "<code>Transpose</code> : Computes <code>transpose</code> of the matrix    <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Transpose"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Invert", "text": "<code>Invert</code> : Finds the inverse of the matrix    <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Invert"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Normalize", "text": "<code>Normalize</code> : <code>Normalize</code> the matrix and remove the translation component.<br> The resulting matrix is an orthonormal matrix (<a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Y\">Y</a> direction preserved, then <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Z\">Z</a>)    <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Normalize"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Adjoint", "text": "<code>Adjoint</code> : Adjugate and <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Determinant\">Determinant</a> functionality.<br> Is used in the computation of the inverse of a matrix<br> So far has only been used in <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#Invert\">Invert</a> and eliminated from assembler algo might not need to do this just keep it for pascal do what it says on the tin anyway as it has combined.    ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Adjoint"},
     {"title": "GLZVectorMath.TGLZMatrix4f.AnglePreservingMatrixInvert", "text": "<code>AnglePreservingMatrixInvert</code> : Finds the inverse of an angle preserving matrix.<br> Angle preserving matrices can combine translation, rotation and isotropic scaling, other matrices won't be properly inverted by this function.    : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#AnglePreservingMatrixInvert"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Decompose", "text": "<code>Decompose</code> : <code>Decompose</code> a non-degenerated 4x4 transformation matrix into the sequence of transformations that produced it.<br> Modified by ml then eg, original Author: Spencer <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html#W\">W</a>. Thomas, University of Michigan. <br> The coefficient of each transformation is returned in the corresponding element of the vector Translation.     Tran : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrixTransformations\">TGLZMatrixTransformations</a> Boolean Return <code>True</code> upon success, false if the matrix is singular. Tran : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrixTransformations\">TGLZMatrixTransformations</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Decompose"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Translate", "text": "<code>Translate</code> : Adds the translation vector into the matrix    V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Translate"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Multiply", "text": "<code>Multiply</code> : Component-wise multiplication    M2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> M2 : <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Multiply"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Rows", "text": "Set or Get a raw of the matrix ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Rows"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Components", "text": "Set or Get element of the matrix ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Components"},
     {"title": "GLZVectorMath.TGLZMatrix4f.Determinant", "text": "Return the <code>determinant</code> of the matrix ", "tags": "", "loc": "GLZVectorMath.TGLZMatrix4f.html#Determinant"},
     {"title": "GLZVectorMath.TGLZEulerAngles", "text": "The Euler angles are three angles to describe the orientation of a rigid body with respect to a fixed coordinate system.<br> They can also represent the orientation of a mobile frame of reference in physics or the orientation of a general basis in 3-dimensional linear algebra. Is used with <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a>.    <p>Remember : <br> - <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#X\">X</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Roll\">Roll</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Bank\">Bank</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Tilt\">Tilt</a> <br> - <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Y\">Y</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Yaw\">Yaw</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Heading\">Heading</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Azimuth\">Azimuth</a> <br> - <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Z\">Z</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Pitch\">Pitch</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Attitude\">Attitude</a> = <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Elevation\">Elevation</a><br>    <p>Source : <a  href=\"https://en.wikipedia.org/wiki/Euler_angles\">https://en.wikipedia.org/wiki/Euler_angles</a>    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem\">https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem</a></p></li>    <li><p><a  href=\"http://ressources.univ-lemans.fr/AccesLibre/UM/Pedago/physique/02/meca/angleeuler.html\">http://ressources.univ-lemans.fr/AccesLibre/UM/Pedago/physique/02/meca/angleeuler.html</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Orientation_\">https://en.wikipedia.org/wiki/Orientation_</a>(geometry)</p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Inertial_navigation_system\">https://en.wikipedia.org/wiki/Inertial_navigation_system</a></p></li>    <li><p><a  href=\"http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\">http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm</a></p></li>    <li><p><a  href=\"http://www.starlino.com/imu_guide.html\">http://www.starlino.com/imu_guide.html</a></p></li>  </ul>    <p> ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#V"},
     {"title": "GLZVectorMath.TGLZEulerAngles.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#X"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Y"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Z"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Roll", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Roll"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Yaw", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Yaw"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Pitch", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Pitch"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Bank", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Bank"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Heading", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Heading"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Attitude", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Attitude"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Tilt", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Tilt"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Azimuth", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Azimuth"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Elevation", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Elevation"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Create\">Create</a> Euler from XYZ angles     X : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#X\">X</a> Angle in deg Y : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Y\">Y</a> Angle in deg Z : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Z\">Z</a> Angle in deg  X : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#X\">X</a> Angle in deg Y : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Y\">Y</a> Angle in deg Z : Single &ndash; <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html#Z\">Z</a> Angle in deg", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Create"},
     {"title": "GLZVectorMath.TGLZEulerAngles.Create", "text": "<code>Create</code> : <code>Create</code> Euler from angles define in an Axis vector   Angles : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; In Deg  Angles : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; In Deg", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#Create"},
     {"title": "GLZVectorMath.TGLZEulerAngles.ConvertToAngleAxis", "text": "<code>ConvertToAngleAxis</code> : Convert Euler angles To Angle and Axis according the rotation order     EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a> &ndash; Default rotation order = YZX Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a> &ndash; Default rotation order = YZX", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#ConvertToAngleAxis"},
     {"title": "GLZVectorMath.TGLZEulerAngles.ConvertToRotationMatrix", "text": "<code>ConvertToRotationMatrix</code> : Convert Euler angles To a rotation matrix according the rotation order    EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a> &ndash; Default rotation order = YZX <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a> &ndash; Default rotation order = YZX", "tags": "", "loc": "GLZVectorMath.TGLZEulerAngles.html#ConvertToRotationMatrix"},
     {"title": "GLZVectorMath.TGLZQuaternion", "text": "<code>TGLZQuaternion</code> : The quaternions are a number system that extends the complex numbers and applied to mechanics in three-dimensional space.<br> A feature of quaternions is that multiplication of two quaternions is noncommutative.<br>    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://en.wikipedia.org/wiki/Quaternion\">https://en.wikipedia.org/wiki/Quaternion</a></p></li>    <li><p><a  href=\"http://developerblog.myo.com/quaternions/\">http://developerblog.myo.com/quaternions/</a></p></li>    <li><p><a  href=\"http://www.chrobotics.com/library/understanding-quaternions\">http://www.chrobotics.com/library/understanding-quaternions</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\">https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a></p></li>    <li><p><a  href=\"http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/\">http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/</a></p></li>    <li><p><a  href=\"http://mathworld.wolfram.com/Quaternion.html\">http://mathworld.wolfram.com/Quaternion.html</a></p></li>  </ul>    <p> ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html"},
     {"title": "GLZVectorMath.V", "text": "Array access ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#V"},
     {"title": "GLZVectorMath.TGLZQuaternion.X", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#X"},
     {"title": "GLZVectorMath.TGLZQuaternion.Y", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Y"},
     {"title": "GLZVectorMath.TGLZQuaternion.Z", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Z"},
     {"title": "GLZVectorMath.TGLZQuaternion.W", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#W"},
     {"title": "GLZVectorMath.TGLZQuaternion.AsVector4f", "text": "As <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#AsVector4f"},
     {"title": "GLZVectorMath.TGLZQuaternion.ImagePart", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#ImagePart"},
     {"title": "GLZVectorMath.TGLZQuaternion.RealPart", "text": "As complex number ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#RealPart"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#Create\">Create</a> a quaternion from the given values      X : Single Y : Single Z : Single Real : Single  X : Single Y : Single Z : Single Real : Single", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#Create\">Create</a> a quaternion from the given values    Imag : Array of single Real : Single  Imag : Array of single Real : Single", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs a unit quaternion from two unit vectors    V1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>  V1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs a unit quaternion from two unit vectors or two points or on unit sphere    V1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  V1 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> V2 : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs a unit quaternion from a matrix. <br> <b>Note :</b> The matrix must be a rotation matrix !   mat : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a>  mat : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs quaternion from angle (in deg) and axis    Angle : Single Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>  Angle : Single Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs quaternion from Euler angles. ( Common Standard Euler Order = YZX )     Yaw : Single Pitch : Single Roll : Single  Yaw : Single Pitch : Single Roll : Single", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs quaternion from Euler angles in arbitrary order (angles in degrees)      X : Single Y : Single Z : Single eulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a>  X : Single Y : Single Z : Single eulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.Create", "text": "<code>Create</code> : Constructs quaternion from Euler angles in arbitrary order (angles in degrees)    EulerAngles : <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html\">TGLZEulerAngles</a> eulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a>  EulerAngles : <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html\">TGLZEulerAngles</a> eulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Create"},
     {"title": "GLZVectorMath.TGLZQuaternion.*", "text": "<code>*</code> : Return quaternion product quatrenion_Left * quaternion_Right. (which is the concatenation of a rotation Q1 followed by the rotation Q2) <br> <b>Note :</b> Order is important reverted to A prod B as B prod A gave wrong results !     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Left B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Right <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Left B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Right", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#*"},
     {"title": "GLZVectorMath.TGLZQuaternion.=", "text": "<code>=</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> are equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#="},
     {"title": "GLZVectorMath.TGLZQuaternion.<", "text": "<code>&lt;</code> : Compare if two <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> are not equal     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> Boolean <code>True</code> if not equal A : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#<"},
     {"title": "GLZVectorMath.TGLZQuaternion.ToString", "text": "<code>ToString</code> :Return Quaternion to a formatted string eg &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#Z\">z</a>, <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#W\">w</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#ToString"},
     {"title": "GLZVectorMath.TGLZQuaternion.ConvertToMatrix", "text": "<code>ConvertToMatrix</code> : Construct a rotation matrix from (possibly non-unit) quaternion. <br> Assumes matrix is used to multiply column vector on the left : <br> vnew = mat * vold. <br> Works correctly for right-handed coordinate system and right-handed rotations.    <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#ConvertToMatrix"},
     {"title": "GLZVectorMath.TGLZQuaternion.ConvertToEuler", "text": "<code>ConvertToEuler</code> : Convert quaternion to Euler Angles according the rotation order    EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZEulerAngles.html\">TGLZEulerAngles</a>  EulerOrder : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZEulerOrder\">TGLZEulerOrder</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#ConvertToEuler"},
     {"title": "GLZVectorMath.TGLZQuaternion.ConvertToAngleAxis", "text": "<code>ConvertToAngleAxis</code> : Convert quaternion to angle (in deg) and axis     Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a>  ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#ConvertToAngleAxis"},
     {"title": "GLZVectorMath.TGLZQuaternion.Conjugate", "text": "<code>Conjugate</code> : Returns the <code>conjugate</code> of a quaternion    <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a>  ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Conjugate"},
     {"title": "GLZVectorMath.TGLZQuaternion.Magnitude", "text": "<code>Magnitude</code> : Returns the <code>magnitude</code> of the quaternion    Single ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Magnitude"},
     {"title": "GLZVectorMath.TGLZQuaternion.Normalize", "text": "<code>Normalize</code> : Normalizes the quaternion    ", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Normalize"},
     {"title": "GLZVectorMath.TGLZQuaternion.Transform", "text": "<code>Transform</code> : Applies rotation to <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html#V\">V</a> around local axes.    V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> V : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Transform"},
     {"title": "GLZVectorMath.TGLZQuaternion.Scale", "text": "<code>Scale</code> : If a <code>scale</code> factor is applied to a quaternion then the rotation will <code>scale</code> vectors when transforming them. <br> Assumes quaternion is already normalized   ScaleVal : Single  ScaleVal : Single", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Scale"},
     {"title": "GLZVectorMath.TGLZQuaternion.MultiplyAsSecond", "text": "<code>MultiplyAsSecond</code> : Returns quaternion product quaternion_Right * quaternion_Left. <br> To combine rotations, use the product Muliply(qSecond, qFirst), which gives the effect of rotating by qFirst then qSecond. <br> <b>Note :</b> order is important !    qFirst : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Quaternion_Right <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> qFirst : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; Quaternion_Right", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#MultiplyAsSecond"},
     {"title": "GLZVectorMath.TGLZQuaternion.Slerp", "text": "<code>Slerp</code> :Spherical linear interpolation of unit quaternions with spins.<br> <b>Note :</b> QStart = Self      QEnd : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; start and end unit quaternions t : Single &ndash; interpolation parameter (0 to 1) Spin : Integer &ndash; number of extra spin rotations to involve <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> QEnd : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; start and end unit quaternions t : Single &ndash; interpolation parameter (0 to 1) Spin : Integer &ndash; number of extra spin rotations to involve", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Slerp"},
     {"title": "GLZVectorMath.TGLZQuaternion.Slerp", "text": "<code>Slerp</code> :Spherical linear interpolation of unit quaternions with spins.<br> <b>Note :</b> QStart = Self     QEnd : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; start and end unit quaternions t : Single &ndash; interpolation parameter (0 to 1) <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> QEnd : <a class=\"normal\" href=\"GLZVectorMath.TGLZQuaternion.html\">TGLZQuaternion</a> &ndash; start and end unit quaternions t : Single &ndash; interpolation parameter (0 to 1)", "tags": "", "loc": "GLZVectorMath.TGLZQuaternion.html#Slerp"},
     {"title": "GLZVectorMath.TGLZVector2iHelper", "text": "Helper for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2iHelper.html"},
     {"title": "GLZVectorMath.TGLZVector2iHelper.Normalize", "text": "<code>Normalize</code> : Return self normalized <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>    <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2iHelper.html#Normalize"},
     {"title": "GLZVectorMath.TGLZVector2fHelper", "text": "Helper for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.Step", "text": "<code>Step</code> :  Implement a <b>step</b> function returning either zero or one.<br> Implements a step function returning one for each component of Self that is greater than or equal to the corresponding component in the reference vector B, and zero otherwise.<br>    <p>see also : <br> &ndash; <a  href=\"http://developer.download.nvidia.com/cg/step.html\">http://developer.download.nvidia.com/cg/step.html</a> <br> &ndash; <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#Step"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.Saturate", "text": "<code>Saturate</code> : Return smallest integer not less than a scalar or each vector component.<br> Return Self saturated to the range [0,1] as follows : <br> </p>    <ol class=\"paragraph_spacing\">    <li value=\"1\"><p>Returns 0 if Self is less than 0; else</p></li>    <li value=\"2\"><p>Returns 1 if Self is greater than 1; else</p></li>    <li value=\"3\"><p>Returns Self otherwise.</p></li>  </ol>    <p>    <p>For vectors, the returned vector contains the saturated result of each element of the vector Self saturated to [0,1].<br>    <p>see also : <br> &ndash; <a  href=\"http://developer.download.nvidia.com/cg/saturate.html\">http://developer.download.nvidia.com/cg/saturate.html</a>     <p>   <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#Saturate"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.SmoothStep", "text": "<code>SmoothStep</code> : Interpolate smoothly between two input values based on a third Interpolates smoothly from 0 to 1 based on Self compared to a and b. <br> </p>    <ol class=\"paragraph_spacing\">    <li value=\"1\"><p>Returns 0 if Self &lt; a &lt; b or Self &gt; a &gt; b</p></li>    <li value=\"2\"><p>Returns 1 if Self &lt; b &lt; a or Self &gt; b &gt; a</p></li>    <li value=\"3\"><p>Returns a value in the range [0,1] for the domain [a,b].</p></li>  </ol>    <p> <br>    <p>if A = Self then, the slope of Self.smoothstep(a,b) and b.smoothstep(a,b) is zero.<br>    <p>For vectors, the returned vector contains the smooth interpolation of each element of the vector x.<br> see also : <br> &ndash; <a  href=\"http://developer.download.nvidia.com/cg/smoothstep.html\">http://developer.download.nvidia.com/cg/smoothstep.html</a> <br> &ndash; <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml</a>     <p>   <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#SmoothStep"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.Lerp", "text": "<code>Lerp</code> : Returns the linear interpolation of Self and B based on weight T.<br> If T has values outside the [0,1] range, it actually extrapolates.    <p>See also : <br> &ndash; <a  href=\"http://developer.download.nvidia.com/cg/lerp.html\">http://developer.download.nvidia.com/cg/lerp.html</a> <br> &ndash; <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml</a>     B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> T : Single <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> T : Single", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#Lerp"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XY", "text": "Quick Swizzling properties access like in HLSL and GLSL  ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XY"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YY"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XXY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XXY"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YYX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YYX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XYY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XYY"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YXX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YXX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XYX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XYX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YXY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YXY"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.XXX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#XXX"},
     {"title": "GLZVectorMath.TGLZVector2fHelper.YYY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVector2fHelper.html#YYY"},
     {"title": "GLZVectorMath.TGLZVectorHelper", "text": "Helper for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html"},
     {"title": "GLZVectorMath.TGLZVectorHelper.Rotate", "text": "<code>Rotate</code> : Returns given vector rotated around arbitrary axis (alpha is in rad, , use Pure Math Model) <br> We are using right hand rule coordinate system.<br> Positive rotations are anticlockwise with postive axis toward you. <br> Posiitve rotations are clockwise viewed from origin along positive axis :. <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>Axis orientation to view positives in Upper Right quadrant [as graph axes] </p></li>    <li><p>With +Z pointing at you (as screen) positive X is to the right positive Y is Up </p></li>    <li><p>With +Y pointing at you positive Z is to the right positive X is Up </p></li>    <li><p>With +X pointing at you positive Y is to the left positive Z is up </p></li>  </ul>    <p>     Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Axis : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#Rotate"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateWithMatrixAroundX", "text": "<code>RotateWithMatrixAroundX</code> : Returns given vector rotated around the X axis (use Pure Math Model)    Alpha : Single &ndash; In Rad <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single &ndash; In Rad", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateWithMatrixAroundX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateWithMatrixAroundY", "text": "<code>RotateWithMatrixAroundY</code> : Returns given vector rotated around the Y axis (use Pure Math Model)    Alpha : Single &ndash; In Rad <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single &ndash; In Rad", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateWithMatrixAroundY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateWithMatrixAroundZ", "text": "<code>RotateWithMatrixAroundZ</code> : Returns given vector rotated around the Z axis (use Pure Math Model)   )  Alpha : Single &ndash; In Rad <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single &ndash; In Rad", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateWithMatrixAroundZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateAroundX", "text": "<code>RotateAroundX</code> : Returns given vector rotated around the X axis. <br> - With +X pointing at you positive Y is to the left positive Z is Up. <br> Positive rotation around x, Y becomes negative.    <p>   Alpha : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateAroundX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateAroundY", "text": "<code>RotateAroundY</code> : Returns given vector rotated around the Y axis. <br> - With +Y pointing at you positive Z is to the right positive X is Up. <br> Positive rotation around y, Z becomes negative.    <p>   Alpha : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateAroundY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.RotateAroundZ", "text": "<code>RotateAroundZ</code> : Returns given vector rotated around the Z axis. <br> - With +Z pointing at you (as screen) positive X is to the right positive Y is Up. <br> Positive rotation around z, X becomes negative    <p>   Alpha : Single &ndash; In Rad <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Alpha : Single &ndash; In Rad", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#RotateAroundZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.PointProject", "text": "<code>PointProject</code> : Projects self on the line defined by Origin and Direction. <br> Performs a DotProduct((p - origin), direction), which, if direction is normalized, computes the distance between origin and the projection of self on the (origin, direction) line.    <p>    Origin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Direction : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Single Origin : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> Direction : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#PointProject"},
     {"title": "GLZVectorMath.TGLZVectorHelper.MoveAround", "text": "<code>MoveAround</code> : Change vector (camera) 's position to make it move around its target.<br> This method helps in quickly implementing camera controls. <br>    <p><b>Note :</b> Angle deltas are in degrees <br>    <p><b>Tips :</b><br> Vector (Camera) parent's coordinates should be identity. <br> Make the Vector (Camera) a child of a &quot;target&quot; dummy and make it a target the dummy. <br> Now, to pan across the scene, just move the dummy, to change viewing angle, use this method.    <p>      AMovingObjectUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> ATargetPosition : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> pitchDelta : Single turnDelta : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; New position AMovingObjectUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> ATargetPosition : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> pitchDelta : Single turnDelta : Single", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#MoveAround"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ShiftObjectFromCenter", "text": "<code>ShiftObjectFromCenter</code> : Translate a point from a Center and a distance      ACenter : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; some point, from which is should be distanced. Distance : Single &ndash; Distance to shift AFromCenterSpo : Boolean <br> &ndash; if <code>True</code> distance, which object should keep from ACenter <br> &ndash; if <code>False</code> distance, which object should shift from his current position away from center. TGLZ  ACenter : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; some point, from which is should be distanced. Distance : Single &ndash; Distance to shift AFromCenterSpo : Boolean <br> &ndash; if <code>True</code> distance, which object should keep from ACenter <br> &ndash; if <code>False</code> distance, which object should shift from his current position away from center.", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ShiftObjectFromCenter"},
     {"title": "GLZVectorMath.TGLZVectorHelper.AverageNormal4", "text": "<code>AverageNormal4</code> : Return the average of 4 points, wich describe a plane       Up : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Left : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Down : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Right : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Up : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Left : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Down : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Right : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#AverageNormal4"},
     {"title": "GLZVectorMath.TGLZVectorHelper.Step", "text": "<code>Step</code> : Implement a <code>step</code> function returning either 0 or 1.<br>    <p>Returns 1 for each component of Self that is greater than or equal to the corresponding component in the reference vector &quot;B&quot;, and 0 otherwise.    <p>see also : <br> - <a  href=\"http://developer.download.nvidia.com/cg/step.html\">http://developer.download.nvidia.com/cg/step.html</a> - <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml</a>    B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#Step"},
     {"title": "GLZVectorMath.TGLZVectorHelper.FaceForward", "text": "<code>FaceForward</code> : Returns a normal as-is if a vertex's eye-space position vector points in the opposite direction of a geometric normal, otherwise return the negated version of the normal <br>    <p><b>Note :</b> Self = Peturbed normal vector.    <p>see also : <br> - <a  href=\"http://developer.download.nvidia.com/cg/faceforward.html\">http://developer.download.nvidia.com/cg/faceforward.html</a> - <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/faceforward.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/faceforward.xhtml</a>    <p>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Incidence vector (typically a direction vector from the eye to a vertex). B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Geometric normal vector (for some facet the peturbed normal belongs). <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Incidence vector (typically a direction vector from the eye to a vertex). B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Geometric normal vector (for some facet the peturbed normal belongs).", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#FaceForward"},
     {"title": "GLZVectorMath.TGLZVectorHelper.Saturate", "text": "<code>Saturate</code> : Returns smallest integer not less than a scalar or each vector component. <br> Returns Self saturated to the range [0,1] as follows:    <p>For vectors, the returned vector contains the saturated result of each element of the vector Self saturated to [0,1]. <br>    <p>see also : <br> - <a  href=\"http://developer.download.nvidia.com/cg/saturate.html\">http://developer.download.nvidia.com/cg/saturate.html</a>    <p>   <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <br> </p>    <ol class=\"paragraph_spacing\">    <li value=\"1\"><p>Returns 0 if Self is less than 0</p></li>    <li value=\"2\"><p>Returns 1 if Self is greater than 1</p></li>    <li value=\"3\"><p>Returns Self otherwise.</p></li>  </ol>    <p> ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#Saturate"},
     {"title": "GLZVectorMath.TGLZVectorHelper.SmoothStep", "text": "<code>SmoothStep</code> : Interpolate smoothly between two input values based on a third <br> Interpolates smoothly from 0 to 1 based on Self compared to a and b.    <p>if A = Self then <br> The slope of Self.smoothstep(a,b) and b.smoothstep(a,b) is zero.    <p>For vectors, the returned vector contains the smooth interpolation of each element of the vector x.    <p>see also : <br> - <a  href=\"http://developer.download.nvidia.com/cg/smoothstep.html\">http://developer.download.nvidia.com/cg/smoothstep.html</a> <br> - <a  href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml</a>    <p>    A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <br> @undorederedlist(    ) A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#SmoothStep"},
     {"title": "GLZVectorMath.TGLZVectorHelper.Reflect", "text": "<code>Reflect</code> :    N : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>  N : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#Reflect"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XY", "text": "Quick Swizzling Properties values accessability like in HLSL and GLSL.  ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XYZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XYZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XZY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XZY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YXZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YXZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YZX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YZX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZXY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZXY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZYX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZYX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XXX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XXX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YYY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YYY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.ZZZ", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#ZZZ"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YYX", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YYX"},
     {"title": "GLZVectorMath.TGLZVectorHelper.XYY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#XYY"},
     {"title": "GLZVectorMath.TGLZVectorHelper.YXY", "text": " ", "tags": "", "loc": "GLZVectorMath.TGLZVectorHelper.html#YXY"},
     {"title": "GLZVectorMath.TGLZMatrixHelper", "text": "Helper for <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMatrix4f</a> ", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Turn", "text": "<code>Turn</code> : Rotates the given coordinate system (represented by the matrix) around its Y-axis    Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Turn"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Turn", "text": "<code>Turn</code> : Rotates the given coordinate system (represented by the matrix) around MasterUp     MasterUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> MasterUp : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Turn"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Pitch", "text": "<code>Pitch</code> : Rotates the given coordinate system (represented by the matrix) around its X-axis    Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Pitch"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Pitch", "text": "<code>Pitch</code> : Rotates the given coordinate system (represented by the matrix) around MasterRight     MasterRight : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> MasterRight : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Pitch"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Roll", "text": "<code>Roll</code> : Rotates the given coordinate system (represented by the matrix) around its Z-axis    Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Roll"},
     {"title": "GLZVectorMath.TGLZMatrixHelper.Roll", "text": "<code>Roll</code> : Rotates the given coordinate system (represented by the matrix) around MasterDirection     MasterDirection : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> MasterDirection : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Angle : Single", "tags": "", "loc": "GLZVectorMath.TGLZMatrixHelper.html#Roll"},
     {"title": "GLZVectorMath.cColorFloatRatio", "text": "Constant for normalise color byte component to float ", "tags": "", "loc": "GLZVectorMath.html#cColorFloatRatio"},
     {"title": "GLZVectorMath.sse_no_round_bits_mask", "text": "mask for removing old rounding bits to set new bits ", "tags": "", "loc": "GLZVectorMath.html#sse_no_round_bits_mask"},
     {"title": "GLZVectorMath.mxcsr_default", "text": "Default value of the mxcsr after booting the PC<br> Default setting of the mxscr register ; disable all exception's ", "tags": "", "loc": "GLZVectorMath.html#mxcsr_default"},
     {"title": "GLZVectorMath.sse_Rounding_Flags", "text": "sse_MaskPosRound; Conversion table from rounding mode name to rounding bits ", "tags": "", "loc": "GLZVectorMath.html#sse_Rounding_Flags"},
     {"title": "GLZVectorMath.sse_align", "text": "SIMD Data Alignement Constant in bits  ", "tags": "", "loc": "GLZVectorMath.html#sse_align"},
     {"title": "GLZVectorMath.sse_align_mask", "text": "Mask for data alignement ", "tags": "", "loc": "GLZVectorMath.html#sse_align_mask"},
     {"title": "GLZVectorMath.cPlaneFront", "text": "Half space representation.  ", "tags": "", "loc": "GLZVectorMath.html#cPlaneFront"},
     {"title": "GLZVectorMath.cPlaneBack", "text": " ", "tags": "", "loc": "GLZVectorMath.html#cPlaneBack"},
     {"title": "GLZVectorMath.cPlanePlanar", "text": " ", "tags": "", "loc": "GLZVectorMath.html#cPlanePlanar"},
     {"title": "GLZVectorMath.cPlaneClipped", "text": " ", "tags": "", "loc": "GLZVectorMath.html#cPlaneClipped"},
     {"title": "GLZVectorMath.cPlaneCulled", "text": " ", "tags": "", "loc": "GLZVectorMath.html#cPlaneCulled"},
     {"title": "GLZVectorMath.cPlaneVisible", "text": " ", "tags": "", "loc": "GLZVectorMath.html#cPlaneVisible"},
     {"title": "GLZVectorMath.NullVector2f", "text": "standard 2D vectors  ", "tags": "", "loc": "GLZVectorMath.html#NullVector2f"},
     {"title": "GLZVectorMath.OneVector2f", "text": " ", "tags": "", "loc": "GLZVectorMath.html#OneVector2f"},
     {"title": "GLZVectorMath.NullVector2d", "text": " ", "tags": "", "loc": "GLZVectorMath.html#NullVector2d"},
     {"title": "GLZVectorMath.OneVector2d", "text": " ", "tags": "", "loc": "GLZVectorMath.html#OneVector2d"},
     {"title": "GLZVectorMath.NullVector2i", "text": " ", "tags": "", "loc": "GLZVectorMath.html#NullVector2i"},
     {"title": "GLZVectorMath.OneVector2i", "text": " ", "tags": "", "loc": "GLZVectorMath.html#OneVector2i"},
     {"title": "GLZVectorMath.XVector", "text": "standard affine vectors  ", "tags": "", "loc": "GLZVectorMath.html#XVector"},
     {"title": "GLZVectorMath.YVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#YVector"},
     {"title": "GLZVectorMath.ZVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#ZVector"},
     {"title": "GLZVectorMath.XYVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XYVector"},
     {"title": "GLZVectorMath.XZVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XZVector"},
     {"title": "GLZVectorMath.YZVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#YZVector"},
     {"title": "GLZVectorMath.XYZVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XYZVector"},
     {"title": "GLZVectorMath.NullVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#NullVector"},
     {"title": "GLZVectorMath.XHmgVector", "text": "standard homogeneous vectors  ", "tags": "", "loc": "GLZVectorMath.html#XHmgVector"},
     {"title": "GLZVectorMath.YHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#YHmgVector"},
     {"title": "GLZVectorMath.ZHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#ZHmgVector"},
     {"title": "GLZVectorMath.WHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#WHmgVector"},
     {"title": "GLZVectorMath.NullHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#NullHmgVector"},
     {"title": "GLZVectorMath.XYHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XYHmgVector"},
     {"title": "GLZVectorMath.YZHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#YZHmgVector"},
     {"title": "GLZVectorMath.XZHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XZHmgVector"},
     {"title": "GLZVectorMath.XYZHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XYZHmgVector"},
     {"title": "GLZVectorMath.XYZWHmgVector", "text": " ", "tags": "", "loc": "GLZVectorMath.html#XYZWHmgVector"},
     {"title": "GLZVectorMath.XHmgPoint", "text": "standard homogeneous points  ", "tags": "", "loc": "GLZVectorMath.html#XHmgPoint"},
     {"title": "GLZVectorMath.YHmgPoint", "text": " ", "tags": "", "loc": "GLZVectorMath.html#YHmgPoint"},
     {"title": "GLZVectorMath.ZHmgPoint", "text": " ", "tags": "", "loc": "GLZVectorMath.html#ZHmgPoint"},
     {"title": "GLZVectorMath.WHmgPoint", "text": " ", "tags": "", "loc": "GLZVectorMath.html#WHmgPoint"},
     {"title": "GLZVectorMath.NullHmgPoint", "text": " ", "tags": "", "loc": "GLZVectorMath.html#NullHmgPoint"},
     {"title": "GLZVectorMath.NegativeUnitVector", "text": "Negative Homogenous Unit Vector ", "tags": "", "loc": "GLZVectorMath.html#NegativeUnitVector"},
     {"title": "GLZVectorMath.IdentityHmgMatrix", "text": "Identity Homogenous Matrix ", "tags": "", "loc": "GLZVectorMath.html#IdentityHmgMatrix"},
     {"title": "GLZVectorMath.EmptyHmgMatrix", "text": "Empty Homogenous Matrix ", "tags": "", "loc": "GLZVectorMath.html#EmptyHmgMatrix"},
     {"title": "GLZVectorMath.IdentityQuaternion", "text": "Identity Quaternion ", "tags": "", "loc": "GLZVectorMath.html#IdentityQuaternion"},
     {"title": "GLZVectorMath.sse_GetRoundMode", "text": "Return current SIMD Rounding Mode    ", "tags": "", "loc": "GLZVectorMath.html#sse_GetRoundMode"},
     {"title": "GLZVectorMath.sse_SetRoundMode", "text": "Set current SIMD Rounding Mode    ", "tags": "", "loc": "GLZVectorMath.html#sse_SetRoundMode"},
     {"title": "GLZVectorMath.sse_Rounding_Mode", "text": "Kind of SIMD rounding mode  rmNearestSSE    rmFloorSSE    rmCeilSSE    rmDefaultSSE   ", "tags": "", "loc": "GLZVectorMath.html#sse_Rounding_Mode"},
     {"title": "GLZVectorMath.TGLZVector2fType", "text": "Aligned array for 2D Single Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector2fType"},
     {"title": "GLZVectorMath.TGLZVector2dType", "text": "Aligned array for 2D Double Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector2dType"},
     {"title": "GLZVectorMath.TGLZVector2iType", "text": "Aligned array for 2D Integer Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector2iType"},
     {"title": "GLZVectorMath.TGLZVector3fType", "text": "Aligned array for 3D Single Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector3fType"},
     {"title": "GLZVectorMath.TGLZVector3iType", "text": "Aligned array for 3D Integer Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector3iType"},
     {"title": "GLZVectorMath.TGLZVector3bType", "text": "Aligned array for 3D Byte Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector3bType"},
     {"title": "GLZVectorMath.TGLZVector4fType", "text": "Aligned array for 4D Single Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector4fType"},
     {"title": "GLZVectorMath.TGLZVector4iType", "text": "Aligned array for 4D Integer Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector4iType"},
     {"title": "GLZVectorMath.TGLZVector4bType", "text": "Aligned array for 4D Byte Vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector4bType"},
     {"title": "GLZVectorMath.TGLZVector3SwizzleRef", "text": "Reference for swizzle (shuffle) 3D Vectors  swDefaultSwizzle3    swXXX    swYYY    swZZZ    swXYZ    swXZY    swZYX    swZXY    swYXZ    swYZX    swRRR    swGGG    swBBB    swRGB    swRBG    swBGR    swBRG    swGRB    swGBR   ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector3SwizzleRef"},
     {"title": "GLZVectorMath.TGLZVector4SwizzleRef", "text": "Reference for swizzle (shuffle) 4D Vectors  swDefaultSwizzle4    swXXXX    swYYYY    swZZZZ    swWWWW    swXYZW    swXZYW    swZYXW    swZXYW    swYXZW    swYZXW    swWXYZ    swWXZY    swWZYX    swWZXY    swWYXZ    swWYZX    swRRRR    swGGGG    swBBBB    swAAAA    swRGBA    swRBGA    swBGRA    swBRGA    swGRBA    swGBRA    swARGB    swARBG    swABGR    swABRG    swAGRB    swAGBR   ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector4SwizzleRef"},
     {"title": "GLZVectorMath.TGLZAffineVector", "text": "Spelling convenience for vector3f, describe an affine vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZAffineVector"},
     {"title": "GLZVectorMath.PGLZAffineVector", "text": "Pointer of <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> ", "tags": "", "loc": "GLZVectorMath.html#PGLZAffineVector"},
     {"title": "GLZVectorMath.TGLZVector", "text": "Spelling convenience for <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a>, describe an homogenous vector ", "tags": "", "loc": "GLZVectorMath.html#TGLZVector"},
     {"title": "GLZVectorMath.PGLZVector", "text": "Pointer of <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> ", "tags": "", "loc": "GLZVectorMath.html#PGLZVector"},
     {"title": "GLZVectorMath.TGLZColorVector", "text": "@TODO Make Independant ", "tags": "", "loc": "GLZVectorMath.html#TGLZColorVector"},
     {"title": "GLZVectorMath.TGLZClipRect", "text": "@TODO Make Independant ", "tags": "", "loc": "GLZVectorMath.html#TGLZClipRect"},
     {"title": "GLZVectorMath.TGLZHmgPlaneHalfSpace", "text": "Positions for point relative to the normal axis of a plane.<br> The positive definition is relative to the normal vector direction  phsIsOnNegativeSide  On negative side.  phsIsOnPositiveSide  On positive side.  phsIsOnPlane  Directly on plane.  phsIsClipped  Clipped by plane.  phsIsAway  Away from plane. ", "tags": "", "loc": "GLZVectorMath.html#TGLZHmgPlaneHalfSpace"},
     {"title": "GLZVectorMath.TGLZMatrixTransType", "text": "Transformation actions type  ttScaleX    ttScaleY    ttScaleZ    ttShearXY    ttShearXZ    ttShearYZ    ttRotateX    ttRotateY    ttRotateZ    ttTranslateX    ttTranslateY    ttTranslateZ    ttPerspectiveX    ttPerspectiveY    ttPerspectiveZ    ttPerspectiveW   ", "tags": "", "loc": "GLZVectorMath.html#TGLZMatrixTransType"},
     {"title": "GLZVectorMath.TGLZMatrixTransformations", "text": "<code>TGLZMatrixTransformations</code> is used to describe a sequence of transformations in following order:<br> [Sx][Sy][Sz][ShearXY][ShearXZ][ShearZY][Rx][Ry][Rz][Tx][Ty][Tz][P(x,y,z,w)]<br> Constants are declared for easier access (see MatrixDecompose below) ", "tags": "", "loc": "GLZVectorMath.html#TGLZMatrixTransformations"},
     {"title": "GLZVectorMath.TGLZMatrix", "text": "Spelling convenience for <a class=\"normal\" href=\"GLZVectorMath.TGLZMatrix4f.html\">TGLZMAtrix4f</a>, describe a 4D float matrix ", "tags": "", "loc": "GLZVectorMath.html#TGLZMatrix"},
     {"title": "GLZVectorMath.PGLZMatrix", "text": "Pointer of <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> ", "tags": "", "loc": "GLZVectorMath.html#PGLZMatrix"},
     {"title": "GLZVectorMath.TGLZEulerOrder", "text": "Euler Angle rotation order.<br> Here, We're using the Tait–Bryan angles conventions for the definition of the rotation axes<br> (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z).  eulXYZ    eulXZY    eulYXZ    eulYZX    eulZXY    eulZYX   ", "tags": "", "loc": "GLZVectorMath.html#TGLZEulerOrder"},
     {"title": "GLZVectorMathEx", "text": "====&lt; GLZVectorMathEx.pas &gt;=====================================================<br>    <p>      <p>Historique : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>Last Update : 13/03/2018 </p></li>    <li><p>12/03/2018 : Creation </p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> Description :<br> <code>GLZVectorMathEx</code> Contains extra optimized classes using SIMD (SSE, SSE3, SS4, AVX, AVX2) acceleration<br> Those classes are specialized and must be in graphic rendering/physics engine It can be used in 2D/3D graphics, computing apps, games...<br>    <p>Support :<br> </p>    <p>      <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> <b>Notes :</b><br>    <p>Some links as references :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p></p></li>  </ul>    <p><br>    <p>Quelques liens en français (in french) :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p></p></li>  </ul>    <p><br>    <p>Others interesting articles, papers at some points:<br> </p>    <ul class=\"paragraph_spacing\">    <li><p></p></li>  </ul>    <p><br>    <p>You can also found some papers in <b>DocRefs</b> folder<br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>    <p><b>Credits :</b><br> </p>    <ul class=\"paragraph_spacing\">    <li><p>FPC/Lazarus</p></li>    <li><p>GLScene</p></li>    <li><p>All authors of papers and web links</p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> LICENCE : MPL <br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> *============================================================================== J.Delauney (BeanzMaster)  Peter Dyson (Dicepd)  ", "tags": "", "loc": "GLZVectorMathEx.html"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix", "text": "<code>TGLZ2DSingleAffineMatrix</code> : Represent a 2D affine transformation as a 3x3 matrix    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://computergraphics.stackexchange.com/questions/391/what-are-affine-transformations\">https://computergraphics.stackexchange.com/questions/391/what-are-affine-transformations</a></p></li>    <li><p><a  href=\"https://en.wikipedia.org/wiki/Affine_transformation\">https://en.wikipedia.org/wiki/Affine_transformation</a></p></li>    <li><p><a  href=\"http://blog.lotech.org/2013/05/the-beauty-of-using-matrices-to-apply.html\">http://blog.lotech.org/2013/05/the-beauty-of-using-matrices-to-apply.html</a></p></li>    <li><p><a  href=\"https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html\">https://webglfundamentals.org/webgl/lessons/fr/webgl-2d-matrices.html</a></p></li>    <li><p><a  href=\"https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm\">https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm</a></p></li>    <li><p><a  href=\"https://code.tutsplus.com/tutorials/understanding-affine-transformations-with-matrix-mathematics--active-10884\">https://code.tutsplus.com/tutorials/understanding-affine-transformations-with-matrix-mathematics--active-10884</a></p></li>    <li><p><a  href=\"http://negativeprobability.blogspot.in/2011/11/affine-transformations-and-their.html\">http://negativeprobability.blogspot.in/2011/11/affine-transformations-and-their.html</a></p></li>    <li><p><a  href=\"https://homepages.inf.ed.ac.uk/rbf/HIPR2/affine.htm\">https://homepages.inf.ed.ac.uk/rbf/HIPR2/affine.htm</a></p></li>    <li><p><a  href=\"http://ncase.me/matrix/\">http://ncase.me/matrix/</a></p></li>  </ul>    <p> ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.M", "text": "The elements of the matrix in row-major order ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#M"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.V", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#V"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.X", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#X"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Y", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Y"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Z", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Z"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m11", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m11"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m12", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m12"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m13", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m13"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m21", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m21"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m22", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m22"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m23", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m23"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m31", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m31"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m32", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m32"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.m33", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#m33"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateIdentityMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateIdentityMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateNullMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateNullMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateTranslationMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateTranslationMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateTranslationMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateTranslationMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateScaleMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateScaleMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateScaleMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateScaleMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateRotationMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateRotationMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateShearMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateShearMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateShearMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateShearMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateReflectXMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateReflectXMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateReflectYMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateReflectYMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.CreateReflectMatrix", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#CreateReflectMatrix"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Create", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Create"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Create", "text": "    ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Create"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.ToString", "text": "<code>ToString</code> : Return Matrix to a formatted string :<br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Z\">Z</a>&quot;)&quot; <br> &quot;(&quot;<a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#X\">x</a>, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Y\">y</a>, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Z\">Z</a>&quot;)&quot; <br> &quot;(&quot;0, 0, 1&quot;)&quot; <br>    String ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#ToString"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.*", "text": "<code>*</code> : Multiplies two matrices     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#*"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.*", "text": "<code>*</code> : Transforms a vector by multiplying it with a matrix     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> B : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#*"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.*", "text": "<code>*</code> : Transforms a vector by multiplying it with a matrix     A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> A : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#*"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Transpose", "text": "<code>Transpose</code> : Computes <code>transpose</code> of the matrix    <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Transpose"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Invert", "text": "<code>Invert</code> : Finds the inverse of the matrix    <a class=\"normal\" href=\"GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html\">TGLZ2DSingleAffineMatrix</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Invert"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Components", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Components"},
     {"title": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.Determinant", "text": "Get <code>Determinant</code> of the matrix @return(Single) ", "tags": "", "loc": "GLZVectorMathEx.TGLZ2DSingleAffineMatrix.html#Determinant"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox", "text": "Describe a 3D Oriented Bounding Box &quot;OBB&quot;<br> An OBB is define by eight point (position of each corner of the &quot;box&quot;)    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://en.wikipedia.org/wiki/Minimum_bounding_box\">https://en.wikipedia.org/wiki/Minimum_bounding_box</a></p></li>    <li><p><a  href=\"https://geidav.wordpress.com/tag/oriented-bounding-box/\">https://geidav.wordpress.com/tag/oriented-bounding-box/</a></p></li>    <li><p><a  href=\"https://graphics.ethz.ch/teaching/former/seminar02/handouts/collisiondetection.pdf\">https://graphics.ethz.ch/teaching/former/seminar02/handouts/collisiondetection.pdf</a></p></li>    <li><p><a  href=\"http://www.idt.mdh.se/~tla/publ/FastOBBs.pdf\">http://www.idt.mdh.se/&tilde;tla/publ/FastOBBs.pdf</a></p></li>    <li><p><a  href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.717.9566&amp;rep=rep1&amp;type=pdf\">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.717.9566&amp;rep=rep1&amp;type=pdf</a></p></li>    <li><p><a  href=\"https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf\">https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf</a></p></li>    <li><p><a  href=\"http://gamma.cs.unc.edu/users/gottschalk/main.pdf\">http://gamma.cs.unc.edu/users/gottschalk/main.pdf</a></p></li>  </ul>    <p><br> <b>Note :</b> For use it, it will be recommended to wrap it in classes <br> <b>UNFINISHED</b> ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html"},
     {"title": "GLZVectorMathEx.Points", "text": "Array access ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#Points"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt1", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt1"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt2", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt2"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt3", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt3"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt4", "text": "Legacy access ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt4"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt5", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt5"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt6", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt6"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt7", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt7"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.pt8", "text": " ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#pt8"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.Create", "text": "<code>Create</code> : <code>Create</code> a minimal Oriented Bounding Box from a point   AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; A Point  AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> &ndash; A Point", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.+", "text": "<code>+</code> : Add two OBB     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#+"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.+", "text": "<code>+</code> : Add to the OBB a point (Extend the bounding box)     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#+"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.=", "text": "<code>=</code> : Compare if two Oriented Bounding Box are equal     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> Boolean <code>True</code> if equal A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#="},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.Transform", "text": "<code>Transform</code> : Applies a 4x4 affine transformation matrix to a bounding sphere.    M : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> M : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#Transform"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MinX", "text": "<code>MinX</code> : Return the minimum of X    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MinX"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MaxX", "text": "<code>MaxX</code> : Return the maximum of X    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MaxX"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MinY", "text": "<code>MinY</code> : Return the minimum of Y    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MinY"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MaxY", "text": "<code>MaxY</code> : Return the maximum of Y    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MaxY"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MinZ", "text": "<code>MinZ</code> : Return the minimum of Z    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MinZ"},
     {"title": "GLZVectorMathEx.TGLZBoundingBox.MaxZ", "text": "<code>MaxZ</code> : Return the maximum of Z    single ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingBox.html#MaxZ"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere", "text": "<code>TGLZBoundingSphere</code> : Describe a very Bounding Sphere system    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://en.wikipedia.org/wiki/Bounding_sphere\">https://en.wikipedia.org/wiki/Bounding_sphere</a></p></li>    <li><p><a  href=\"https://www.ep.liu.se/ecp/034/009/ecp083409.pdf\">https://www.ep.liu.se/ecp/034/009/ecp083409.pdf</a></p></li>    <li><p><a  href=\"https://www.mvps.org/directx/articles/using_bounding_spheres.htm\">https://www.mvps.org/directx/articles/using_bounding_spheres.htm</a></p></li>  </ul>    <p><br> <b>Note :</b> For use it, it will be recommended to wrap it in classes <br> <b>UNFINISHED</b> ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html"},
     {"title": "GLZVectorMathEx.Center", "text": "<code>Center</code> of Bounding Sphere ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Center"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Radius", "text": "<code>Radius</code> of Bounding Sphere ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Radius"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Create\">Create</a> a bounding sphere      X : Single Y : Single Z : Single R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0  X : Single Y : Single Z : Single R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Create"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Create\">Create</a> a bounding sphere    AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0  AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZAffineVector\">TGLZAffineVector</a> R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Create"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Create", "text": "<code>Create</code> : <code>Create</code> a bounding sphere    AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0  AValue : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> R : Single &ndash; <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a> default 1.0", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Create"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.ToString", "text": "<code>ToString</code> : Return Bounding Sphere to a formatted string eg &quot;(&quot;x, y, z, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html#Radius\">Radius</a>&quot;)&quot;    String ", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#ToString"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Contains", "text": "<code>Contains</code> : Determines the space intersection of the Bounding Sphere with another Bounding Sphere    TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a> <a class=\"normal\" href=\"GLZVectorMathEx.html#TGLZSpaceContains\">TGLZSpaceContains</a> TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Contains"},
     {"title": "GLZVectorMathEx.TGLZBoundingSphere.Intersect", "text": "<code>Intersect</code> : Determines if the Bounding Sphere intersects another Bounding Sphere    TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a> Boolean <code>True</code> if <code>Intersect</code> TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZBoundingSphere.html#Intersect"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox", "text": "<code>TGLZAxisAlignedBoundingBox</code> : Describe a 3D Axis Aligned Bounding Box (AABB)    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"https://en.wikipedia.org/wiki/Bounding_volume\">https://en.wikipedia.org/wiki/Bounding_volume</a></p></li>    <li><p><a  href=\"https://www.gamasutra.com/view/feature/131833/when_two_hearts_collide_.php\">https://www.gamasutra.com/view/feature/131833/when_two_hearts_collide_.php</a></p></li>    <li><p><a  href=\"https://developer.mozilla.org/kab/docs/Games/Techniques/2D_collision_detection\">https://developer.mozilla.org/kab/docs/Games/Techniques/2D_collision_detection</a></p></li>    <li><p><a  href=\"https://www.azurefromthetrenches.com/introductory-guide-to-aabb-tree-collision-detection/\">https://www.azurefromthetrenches.com/introductory-guide-to-aabb-tree-collision-detection/</a></p></li>    <li><p><a  href=\"http://www.gamefromscratch.com/post/2012/11/26/GameDev-math-recipes-Collision-detection-using-an-axis-aligned-bounding-box.aspx\">http://www.gamefromscratch.com/post/2012/11/26/GameDev-math-recipes-Collision-detection-using-an-axis-aligned-bounding-box.aspx</a></p></li>    <li><p><a  href=\"https://www.researchgate.net/publication/303703971_An_intensity_recovery_algorithm_IRA_for_minimizing_the_edge_effect_of_LIDAR_data\">https://www.researchgate.net/publication/303703971_An_intensity_recovery_algorithm_IRA_for_minimizing_the_edge_effect_of_LIDAR_data</a></p></li>    <li><p><a  href=\"http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Inproceedings@117681e94b6_1860ffd/bounding_volume_hierarchies.pdf\">http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Inproceedings@117681e94b6_1860ffd/bounding_volume_hierarchies.pdf</a></p></li>  </ul>    <p><br> <b>Note :</b> For use it, it will be recommended to wrap it in classes <br> <b>UNFINISHED</b> ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Min", "text": "function RayCastIntersect(const RayOrigin, RayDirection: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>; out TNear, TFar: Single): Boolean; overload; function RayCastIntersect(const RayOrigin, RayDirection: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>; IntersectPoint: <a class=\"normal\" href=\"GLZVectorMath.html#PGLZVector\">PGLZVector</a> = nil): Boolean; overload; ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Min"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Max", "text": "function RayCastIntersect(const RayOrigin, RayDirection: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>; out TNear, TFar: Single): Boolean; overload; function RayCastIntersect(const RayOrigin, RayDirection: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>; IntersectPoint: <a class=\"normal\" href=\"GLZVectorMath.html#PGLZVector\">PGLZVector</a> = nil): Boolean; overload; ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Max"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create\">Create</a> AABB from one point   AValue: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  AValue: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create\">Create</a> AABB from two bounding points    AMin: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> AMax: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>  AMin: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> AMax: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Create", "text": "<code>Create</code> : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create\">Create</a> the AABB information from an OBB.   ABB: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a>  ABB: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.CreateFromSweep", "text": "<code>CreateFromSweep</code> : Make the AABB that is formed by sweeping a sphere (or AABB) from Start to Dest    <p>More informations :<br> </p>    <ul class=\"paragraph_spacing\">    <li><p><a  href=\"http://physicsforgames.blogspot.in/2010/03/narrow-phase-sweeping-sphere-against.html\">http://physicsforgames.blogspot.in/2010/03/narrow-phase-sweeping-sphere-against.html</a></p></li>    <li><p><a  href=\"https://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php\">https://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php</a></p></li>  </ul>    <p>     Start : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Dest : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius : Single  Start : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Dest : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius : Single", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#CreateFromSweep"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Create", "text": "<code>Create</code> : Convert a BSphere to the AABB   BSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>  BSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Create", "text": "<code>Create</code> : Convert a BSphere to the AABB    Center: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius: Single  Center: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Radius: Single", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Create"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.+", "text": "<code>+</code> : Add one AABB to another AABB     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#+"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.+", "text": "<code>+</code> : Add one Point to another AABB     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#+"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.*", "text": "<code>*</code> : Scale an AABB by a vector     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#*"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.=", "text": "<code>=</code> : Compare if two AABB are equal     A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <code>True</code> if equal. <code>False</code> otherwise A : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B : <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#="},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Transform", "text": "<code>Transform</code> : <code>Transform</code> the AABB by a matrix    M:TGLZMatrix  <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> M:TGLZMatrix ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Transform"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Include", "text": "<code>Include</code> : Extend the AABB with the point P    P:TGLZVector  <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> P:TGLZVector ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Include"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Intersection", "text": "<code>Intersection</code> Returns the <code>intersection</code> of the AABB with second AABBs.<br> If the AABBs don't <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersect\">intersect</a>, will return a degenerated AABB (plane, line or point).    B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersection"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.ToBoundingBox", "text": "<code>ToBoundingBox</code> : Converts the AABB to its canonical BB.    <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#ToBoundingBox"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.ToBoundingBox", "text": "<code>ToBoundingBox</code> : Converts the transformed AABB to a BB.    M: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingBox.html\">TGLZBoundingBox</a> M: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#ToBoundingBox"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.ToBoundingSphere", "text": "<code>ToBoundingSphere</code> : Convert the AABB to a BSphere    <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#ToBoundingSphere"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Intersect", "text": "<code>Intersect</code> : Determines if self <code>Intersect</code> with another Axis Aligned Bounding Box.<br> The matrices are the ones that convert one point to the other's AABB system. <br> m1 : Rotation matrix; m2 : TranslationAndScale Matrix ????      B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> M1: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> M2: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> <code>True</code> if <code>intersect</code>. <code>False</code> otherwise B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> M1: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a> M2: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZMatrix\">TGLZMatrix</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersect"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.IntersectAbsoluteXY", "text": "<code>IntersectAbsoluteXY</code> : Checks whether self collide with another Axis Aligned Bounding Box in the XY plane.    B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <code>True</code> if <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersect\">intersect</a>. <code>False</code> otherwise B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#IntersectAbsoluteXY"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.IntersectAbsoluteXZ", "text": "<code>IntersectAbsoluteXZ</code> : Checks whether self collide with another Axis Aligned Bounding Box in the XZ plane.    B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <code>True</code> if <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersect\">intersect</a>. <code>False</code> otherwise B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#IntersectAbsoluteXZ"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.IntersectAbsolute", "text": "<code>IntersectAbsolute</code> : Checks whether self collide with another Axis Aligned Bounding Box, aligned with the world axes .    B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <code>True</code> if <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Intersect\">intersect</a>. <code>False</code> otherwise B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#IntersectAbsolute"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.FitsInAbsolute", "text": "<code>FitsInAbsolute</code> : Checks whether self fits within another Bounding box, aligned with the world axes .    B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <code>True</code> if fit. <code>False</code> otherwise B: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#FitsInAbsolute"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.PointIn", "text": "<code>PointIn</code> : Checks if a point &quot;p&quot; is inside the AABB    P: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> <code>True</code> if inside. <code>False</code> otherwise P: <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#PointIn"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.ExtractCorners", "text": "<code>ExtractCorners</code> : Extract the corners from the AABB    <a class=\"normal\" href=\"GLZVectorMathEx.html#TGLZAABBCorners\">TGLZAABBCorners</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#ExtractCorners"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Contains", "text": "<code>Contains</code> : Determines to which extent the AABB <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Contains\">contains</a> another AABB    TestAABB: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> <a class=\"normal\" href=\"GLZVectorMathEx.html#TGLZSpaceContains\">TGLZSpaceContains</a> TestAABB: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Contains"},
     {"title": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.Contains", "text": "<code>Contains</code> : Determines to which extent the AABB <code>contains</code> a BSphere    TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a> <a class=\"normal\" href=\"GLZVectorMathEx.html#TGLZSpaceContains\">TGLZSpaceContains</a> TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#Contains"},
     {"title": "GLZVectorMathEx.TGLZHmgPlaneHelper", "text": "Helper for <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a><br> Used for functions where we use types not declared before <a class=\"normal\" href=\"GLZVectorMath.TGLZHmgPlane.html\">TGLZHmgPlane</a> ", "tags": "", "loc": "GLZVectorMathEx.TGLZHmgPlaneHelper.html"},
     {"title": "GLZVectorMathEx.TGLZHmgPlaneHelper.Contains", "text": "<code>Contains</code> :    TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a> <a class=\"normal\" href=\"GLZVectorMathEx.html#TGLZSpaceContains\">TGLZSpaceContains</a> TestBSphere: <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZHmgPlaneHelper.html#Contains"},
     {"title": "GLZVectorMathEx.TGLZHmgPlaneHelper.EvaluatePoint", "text": "<code>EvaluatePoint</code> : Calculates the cross-product between the plane normal and plane to point vector. <br> This functions gives an hint as to were the point is, if the point is in the half-space pointed by the vector, result is positive. <br> This function performs an homogeneous space dot-product.    Point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a> Single Point : <a class=\"normal\" href=\"GLZVectorMath.html#TGLZVector\">TGLZVector</a>", "tags": "", "loc": "GLZVectorMathEx.TGLZHmgPlaneHelper.html#EvaluatePoint"},
     {"title": "GLZVectorMathEx.NullBoundingBox", "text": "Null Oriented Bounding Box (OBB) ", "tags": "", "loc": "GLZVectorMathEx.html#NullBoundingBox"},
     {"title": "GLZVectorMathEx.TGLZSpaceContains", "text": "Result type for space intersection tests, with Bounding records see also : <br> - <a class=\"normal\" href=\"GLZVectorMathEx.TGLZBoundingSphere.html\">TGLZBoundingSphere</a>, <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html\">TGLZAxisAlignedBoundingBox</a> (3D)<br> - TGLZBoundingCircle, TGLZAxisAlignedBoundingRect (2D)<br>  ScNoOverlap    ScContainsFully    ScContainsPartially   ", "tags": "", "loc": "GLZVectorMathEx.html#TGLZSpaceContains"},
     {"title": "GLZVectorMathEx.TGLZAABBCorners", "text": "<code>TGLZAABBCorners</code> : Structure for storing the corners of an AABB, used with <a class=\"normal\" href=\"GLZVectorMathEx.TGLZAxisAlignedBoundingBox.html#ExtractCorners\">TGLZAxisAlignedBoundingBox.ExtractCorners</a> ", "tags": "", "loc": "GLZVectorMathEx.html#TGLZAABBCorners"},
     {"title": "GLZVectorMathEx.TGLZFrustrumPlanesArray", "text": "Convenience for Frustrum planes access ", "tags": "", "loc": "GLZVectorMathEx.html#TGLZFrustrumPlanesArray"},
     {"title": "GLZVectorMathUtils", "text": "====&lt; GLZVectorMathEx.pas &gt;=====================================================<br>    <p>      <p>Historique : <br> </p>    <ul class=\"paragraph_spacing\">    <li><p>Last Update : 13/03/2018 </p></li>    <li><p>12/03/2018 : Creation </p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> Description :<br> <code>GLZVectorMathUtils</code> Contains extra inline functions for vectors    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> <b>Notes :</b><br>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>    <p><b>Credits :</b><br> </p>    <ul class=\"paragraph_spacing\">    <li><p>FPC/Lazarus</p></li>    <li><p>GLScene</p></li>    <li><p>All authors of papers and web links</p></li>  </ul>    <p>    <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> LICENCE : MPL <br> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br> *============================================================================== J.Delauney (BeanzMaster)  Peter Dyson (Dicepd)  ", "tags": "", "loc": "GLZVectorMathUtils.html"},
     {"title": "GLZVectorMathUtils.AffineVectorMake", "text": "<code>AffineVectorMake</code> : Create a 3D Float single precision affine vector from values      vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z", "tags": "", "loc": "GLZVectorMathUtils.html#AffineVectorMake"},
     {"title": "GLZVectorMathUtils.AffineVectorMake", "text": "<code>AffineVectorMake</code> : Create a 3D Float single precision affine vector from one Homogenous vector    v : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Homogenous vector A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector3f.html\">TGLZVector3f</a> v : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> &ndash; Homogenous vector", "tags": "", "loc": "GLZVectorMathUtils.html#AffineVectorMake"},
     {"title": "GLZVectorMathUtils.vec2", "text": "<code>vec2</code> : Create a 2D Float single precision from values     vX : Single &ndash; value for X vY : Single &ndash; value for Y A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> vX : Single &ndash; value for X vY : Single &ndash; value for Y", "tags": "", "loc": "GLZVectorMathUtils.html#vec2"},
     {"title": "GLZVectorMathUtils.vec4", "text": "<code>vec4</code> : Create a 4D Float single precision homogenous vector from values       vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z vW : Single &ndash; value for W A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z vW : Single &ndash; value for W", "tags": "", "loc": "GLZVectorMathUtils.html#vec4"},
     {"title": "GLZVectorMathUtils.vec4", "text": "<code>vec4</code> : Create a 4D Float single precision homogenous vector from one value as Homogenous    vX : Single &ndash; value for each component A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> vX : Single &ndash; value for each component", "tags": "", "loc": "GLZVectorMathUtils.html#vec4"},
     {"title": "GLZVectorMathUtils.PointVec4", "text": "<code>PointVec4</code> : Create a 4D Float single precision Point vector from values      vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z A <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> vX : Single &ndash; value for X vY : Single &ndash; value for Y vZ : Single &ndash; value for Z", "tags": "", "loc": "GLZVectorMathUtils.html#PointVec4"},
     {"title": "GLZVectorMathUtils.PointVec4", "text": "<code>PointVec4</code> : Create a 4D Float single precision Point vector from values    vX : Single &ndash; value for each component except W (W=1) a <a class=\"normal\" href=\"GLZVectorMath.TGLZVector4f.html\">TGLZVector4f</a> vX : Single &ndash; value for each component except W (W=1)", "tags": "", "loc": "GLZVectorMathUtils.html#PointVec4"},
     {"title": "GLZVectorMathUtils.Trunc", "text": "<code>Trunc</code> : Rounds each component of a 2D float single precision vector towards towards 0    V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <code>Trunc</code> Truncated value as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>  V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <code>Trunc</code>", "tags": "", "loc": "GLZVectorMathUtils.html#Trunc"},
     {"title": "GLZVectorMathUtils.Round", "text": "<code>Round</code> : Rounds each component of a 2D float single precision vector towards its nearest integer    V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <code>round</code> Rounded value as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>  V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <code>round</code>", "tags": "", "loc": "GLZVectorMathUtils.html#Round"},
     {"title": "GLZVectorMathUtils.Floor", "text": "<code>Floor</code> : Rounds each component of a 2D float single precision vector towards negative infinity    V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <a class=\"normal\" href=\"GLZVectorMathUtils.html#Round\">round</a> Floored value as <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2i.html\">TGLZVector2i</a>  V : <a class=\"normal\" href=\"GLZVectorMath.TGLZVector2f.html\">TGLZVector2f</a> &ndash; value to <a class=\"normal\" href=\"GLZVectorMathUtils.html#Round\">round</a>", "tags": "", "loc": "GLZVectorMathUtils.html#Floor"},
     {"title": "GLZVectorMathUtils.Fract", "text": "<code>Fract</code> : Returns the fractional part of each component of a 2D float single precision vector    v value where extract fractionnal part Fractionnal part v value where extract fractionnal part", "tags": "", "loc": "GLZVectorMathUtils.html#Fract"},
     {"title": "GLZVectorMathUtils.Sqrt", "text": "<code>Sqrt</code> : Returns the Square root of each component of a 2D float single precision vector    v value where extract Square root Square root v value where extract Square root", "tags": "", "loc": "GLZVectorMathUtils.html#Sqrt"},
     {"title": "GLZVectorMathUtils.InvSqrt", "text": "<code>InvSqrt</code> : Returns the Inverse Square root of each component of a 2D float single precision vector    v value where extract Square root Inverse Square root v value where extract Square root", "tags": "", "loc": "GLZVectorMathUtils.html#InvSqrt"},
     {"title": "GLZVectorMathUtils.Sin", "text": "<code>Sin</code> : Returns the Sinus of each component of a 2D float single precision vector    v value where compute Sinus Sinus v value where compute Sinus", "tags": "", "loc": "GLZVectorMathUtils.html#Sin"},
     {"title": "GLZVectorMathUtils.Cos", "text": "<code>Cos</code> : Returns the Cosinus of each component of a 2D float single precision vector    v value where compute Cosinus Cosinus v value where compute Cosinus", "tags": "", "loc": "GLZVectorMathUtils.html#Cos"},
     {"title": "GLZVectorMathUtils.SinCos", "text": "<code>SinCos</code> : Returns the Sinus and Cosinus from a single value to each component of a 2D float single precision vector    v value where compute Sinus and Cosinus Sinus in X component and Cosinus in Y component v value where compute Sinus and Cosinus", "tags": "", "loc": "GLZVectorMathUtils.html#SinCos"},
     {"title": "GLZVectorMathUtils.SinCos", "text": "<code>SinCos</code> : Returns the Sinus and Cosinus from a 2D float single precision vector    v value where compute Sinus and Cosinus Sinus of X in X component and Cosinus Y in Y component v value where compute Sinus and Cosinus", "tags": "", "loc": "GLZVectorMathUtils.html#SinCos"},
     {"title": "GLZVectorMathUtils.Fract", "text": "<code>Fract</code> : Returns the fractional part of each component of a 4D float single precision vector    v value where extract fractionnal part Fractionnal part v value where extract fractionnal part", "tags": "", "loc": "GLZVectorMathUtils.html#Fract"},
     {"title": "GLZVectorMathUtils.VectorIsColinear", "text": "<code>VectorIsColinear</code> : Returns true if both vector are colinear     v1 : Vector 1 v2 : Vector 2 <code>True</code> vectors are colinear. <code>False</code> otherwise v1 : Vector 1 v2 : Vector 2", "tags": "", "loc": "GLZVectorMathUtils.html#VectorIsColinear"}
]};
